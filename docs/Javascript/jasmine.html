<!DOCTYPE html>

<html>
<head>
  <title>jasmine.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="SpecRunner.html">
                SpecRunner.js
              </a>
            
              
              <a class="source" href="app.html">
                app.js
              </a>
            
              
              <a class="source" href="dialog.html">
                dialog.js
              </a>
            
              
              <a class="source" href="modal.html">
                modal.js
              </a>
            
              
              <a class="source" href="revealoptions.html">
                revealoptions.js
              </a>
            
              
              <a class="source" href="localstorage.html">
                localstorage.js
              </a>
            
              
              <a class="source" href="alert_controller.html">
                alert_controller.js
              </a>
            
              
              <a class="source" href="alert_view.html">
                alert_view.js
              </a>
            
              
              <a class="source" href="edit_controller.html">
                edit_controller.js
              </a>
            
              
              <a class="source" href="edit_view.html">
                edit_view.js
              </a>
            
              
              <a class="source" href="episodes_app.html">
                episodes_app.js
              </a>
            
              
              <a class="source" href="feed_controller.html">
                feed_controller.js
              </a>
            
              
              <a class="source" href="feed_view.html">
                feed_view.js
              </a>
            
              
              <a class="source" href="list_controller.html">
                list_controller.js
              </a>
            
              
              <a class="source" href="list_view.html">
                list_view.js
              </a>
            
              
              <a class="source" href="nav_controller.html">
                nav_controller.js
              </a>
            
              
              <a class="source" href="nav_view.html">
                nav_view.js
              </a>
            
              
              <a class="source" href="new_view.html">
                new_view.js
              </a>
            
              
              <a class="source" href="player_controller.html">
                player_controller.js
              </a>
            
              
              <a class="source" href="player_view.html">
                player_view.js
              </a>
            
              
              <a class="source" href="playlist_controller.html">
                playlist_controller.js
              </a>
            
              
              <a class="source" href="playlist_view.html">
                playlist_view.js
              </a>
            
              
              <a class="source" href="show_controller.html">
                show_controller.js
              </a>
            
              
              <a class="source" href="show_view.html">
                show_view.js
              </a>
            
              
              <a class="source" href="FeedSpec.html">
                FeedSpec.js
              </a>
            
              
              <a class="source" href="async.html">
                async.js
              </a>
            
              
              <a class="source" href="list_controller.html">
                list_controller.js
              </a>
            
              
              <a class="source" href="list_view.html">
                list_view.js
              </a>
            
              
              <a class="source" href="show_controller.html">
                show_controller.js
              </a>
            
              
              <a class="source" href="show_view.html">
                show_view.js
              </a>
            
              
              <a class="source" href="subscriptions_app.html">
                subscriptions_app.js
              </a>
            
              
              <a class="source" href="build.html">
                build.js
              </a>
            
              
              <a class="source" href="modal.html">
                modal.js
              </a>
            
              
              <a class="source" href="utils.html">
                utils.js
              </a>
            
              
              <a class="source" href="view.html">
                view.js
              </a>
            
              
              <a class="source" href="views.html">
                views.js
              </a>
            
              
              <a class="source" href="episode.html">
                episode.js
              </a>
            
              
              <a class="source" href="feed.html">
                feed.js
              </a>
            
              
              <a class="source" href="player.html">
                player.js
              </a>
            
              
              <a class="source" href="playlist.html">
                playlist.js
              </a>
            
              
              <a class="source" href="subscriptions.html">
                subscriptions.js
              </a>
            
              
              <a class="source" href="topics.html">
                topics.js
              </a>
            
              
              <a class="source" href="require_main.html">
                require_main.js
              </a>
            
              
              <a class="source" href="require_main_built.html">
                require_main_built.js
              </a>
            
              
              <a class="source" href="almond.html">
                almond.js
              </a>
            
              
              <a class="source" href="backbone.babysitter.html">
                backbone.babysitter.js
              </a>
            
              
              <a class="source" href="backbone.html">
                backbone.js
              </a>
            
              
              <a class="source" href="backbone.localstorage.html">
                backbone.localstorage.js
              </a>
            
              
              <a class="source" href="backbone.localstorage.min.html">
                backbone.localstorage.min.js
              </a>
            
              
              <a class="source" href="backbone.marionette.html">
                backbone.marionette.js
              </a>
            
              
              <a class="source" href="backbone.marionette.min.html">
                backbone.marionette.min.js
              </a>
            
              
              <a class="source" href="backbone.picky.html">
                backbone.picky.js
              </a>
            
              
              <a class="source" href="backbone.syphon.html">
                backbone.syphon.js
              </a>
            
              
              <a class="source" href="backbone.wreqr.html">
                backbone.wreqr.js
              </a>
            
              
              <a class="source" href="foundation.fastclick.html">
                foundation.fastclick.js
              </a>
            
              
              <a class="source" href="foundation.html">
                foundation.js
              </a>
            
              
              <a class="source" href="foundation.min.html">
                foundation.min.js
              </a>
            
              
              <a class="source" href="foundation.offcanvas.html">
                foundation.offcanvas.js
              </a>
            
              
              <a class="source" href="foundation.reveal.html">
                foundation.reveal.js
              </a>
            
              
              <a class="source" href="jasmine-html.html">
                jasmine-html.js
              </a>
            
              
              <a class="source" href="jasmine.html">
                jasmine.js
              </a>
            
              
              <a class="source" href="jasmine-html.html">
                jasmine-html.js
              </a>
            
              
              <a class="source" href="jasmine.html">
                jasmine.js
              </a>
            
              
              <a class="source" href="jquery-ui-1.10.3.min.html">
                jquery-ui-1.10.3.min.js
              </a>
            
              
              <a class="source" href="jquery-ui.html">
                jquery-ui.js
              </a>
            
              
              <a class="source" href="jquery.html">
                jquery.js
              </a>
            
              
              <a class="source" href="jquery.transit.html">
                jquery.transit.js
              </a>
            
              
              <a class="source" href="jquery.transmit.html">
                jquery.transmit.js
              </a>
            
              
              <a class="source" href="json2.html">
                json2.js
              </a>
            
              
              <a class="source" href="log.html">
                log.js
              </a>
            
              
              <a class="source" href="modernizr.html">
                modernizr.js
              </a>
            
              
              <a class="source" href="require.html">
                require.js
              </a>
            
              
              <a class="source" href="jasmine-sinon.html">
                jasmine-sinon.js
              </a>
            
              
              <a class="source" href="sinon.html">
                sinon.js
              </a>
            
              
              <a class="source" href="spin.jquery.html">
                spin.jquery.js
              </a>
            
              
              <a class="source" href="spin.html">
                spin.js
              </a>
            
              
              <a class="source" href="tpl.html">
                tpl.js
              </a>
            
              
              <a class="source" href="underscore.html">
                underscore.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>jasmine.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> isCommonJS = <span class="hljs-keyword">typeof</span> window == <span class="hljs-string">"undefined"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> exports == <span class="hljs-string">"object"</span>;

<span class="hljs-comment">/**
 * Top level namespace for Jasmine, a lightweight JavaScript BDD/spec/testing framework.
 *
 * @namespace
 */</span>
<span class="hljs-keyword">var</span> jasmine = {};
<span class="hljs-keyword">if</span> (isCommonJS) exports.jasmine = jasmine;
<span class="hljs-comment">/**
 * @private
 */</span>
jasmine.unimplementedMethod_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"unimplemented method"</span>);
};

<span class="hljs-comment">/**
 * Use &lt;code&gt;jasmine.undefined&lt;/code&gt; instead of &lt;code&gt;undefined&lt;/code&gt;, since &lt;code&gt;undefined&lt;/code&gt; is just
 * a plain old variable and may be redefined by somebody else.
 *
 * @private
 */</span>
jasmine.undefined = jasmine.___undefined___;

<span class="hljs-comment">/**
 * Show diagnostic messages in the console if set to true
 *
 */</span>
jasmine.VERBOSE = <span class="hljs-literal">false</span>;

<span class="hljs-comment">/**
 * Default interval in milliseconds for event loop yields (e.g. to allow network activity or to refresh the screen with the HTML-based runner). Small values here may result in slow test running. Zero means no updates until all tests have completed.
 *
 */</span>
jasmine.DEFAULT_UPDATE_INTERVAL = <span class="hljs-number">250</span>;

<span class="hljs-comment">/**
 * Maximum levels of nesting that will be included when an object is pretty-printed
 */</span>
jasmine.MAX_PRETTY_PRINT_DEPTH = <span class="hljs-number">40</span>;

<span class="hljs-comment">/**
 * Default timeout interval in milliseconds for waitsFor() blocks.
 */</span>
jasmine.DEFAULT_TIMEOUT_INTERVAL = <span class="hljs-number">5000</span>;

<span class="hljs-comment">/**
 * By default exceptions thrown in the context of a test are caught by jasmine so that it can run the remaining tests in the suite.
 * Set to false to let the exception bubble up in the browser.
 *
 */</span>
jasmine.CATCH_EXCEPTIONS = <span class="hljs-literal">true</span>;

jasmine.getGlobal = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getGlobal</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  <span class="hljs-keyword">return</span> getGlobal();
};

<span class="hljs-comment">/**
 * Allows for bound functions to be compared.  Internal use only.
 *
 * @ignore
 * @private
 * @param base {Object} bound 'this' for the function
 * @param name {Function} function to find
 */</span>
jasmine.bindOriginal_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(base, name)</span> {</span>
  <span class="hljs-keyword">var</span> original = base[name];
  <span class="hljs-keyword">if</span> (original.apply) {
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">return</span> original.apply(base, <span class="hljs-built_in">arguments</span>);
    };
  } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>IE support</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> jasmine.getGlobal()[name];
  }
};

jasmine.setTimeout = jasmine.bindOriginal_(jasmine.getGlobal(), <span class="hljs-string">'setTimeout'</span>);
jasmine.clearTimeout = jasmine.bindOriginal_(jasmine.getGlobal(), <span class="hljs-string">'clearTimeout'</span>);
jasmine.setInterval = jasmine.bindOriginal_(jasmine.getGlobal(), <span class="hljs-string">'setInterval'</span>);
jasmine.clearInterval = jasmine.bindOriginal_(jasmine.getGlobal(), <span class="hljs-string">'clearInterval'</span>);

jasmine.MessageResult = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(values)</span> {</span>
  <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'log'</span>;
  <span class="hljs-keyword">this</span>.values = values;
  <span class="hljs-keyword">this</span>.trace = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(); <span class="hljs-comment">// todo: test better</span>
};

jasmine.MessageResult.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> text = <span class="hljs-string">""</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.values.length; i++) {
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) text += <span class="hljs-string">" "</span>;
    <span class="hljs-keyword">if</span> (jasmine.isString_(<span class="hljs-keyword">this</span>.values[i])) {
      text += <span class="hljs-keyword">this</span>.values[i];
    } <span class="hljs-keyword">else</span> {
      text += jasmine.pp(<span class="hljs-keyword">this</span>.values[i]);
    }
  }
  <span class="hljs-keyword">return</span> text;
};

jasmine.ExpectationResult = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(params)</span> {</span>
  <span class="hljs-keyword">this</span>.type = <span class="hljs-string">'expect'</span>;
  <span class="hljs-keyword">this</span>.matcherName = params.matcherName;
  <span class="hljs-keyword">this</span>.passed_ = params.passed;
  <span class="hljs-keyword">this</span>.expected = params.expected;
  <span class="hljs-keyword">this</span>.actual = params.actual;
  <span class="hljs-keyword">this</span>.message = <span class="hljs-keyword">this</span>.passed_ ? <span class="hljs-string">'Passed.'</span> : params.message;

  <span class="hljs-keyword">var</span> trace = (params.trace || <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-keyword">this</span>.message));
  <span class="hljs-keyword">this</span>.trace = <span class="hljs-keyword">this</span>.passed_ ? <span class="hljs-string">''</span> : trace;
};

jasmine.ExpectationResult.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message;
};

jasmine.ExpectationResult.prototype.passed = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.passed_;
};

<span class="hljs-comment">/**
 * Getter for the Jasmine environment. Ensures one gets created
 */</span>
jasmine.getEnv = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> env = jasmine.currentEnv_ = jasmine.currentEnv_ || <span class="hljs-keyword">new</span> jasmine.Env();
  <span class="hljs-keyword">return</span> env;
};

<span class="hljs-comment">/**
 * @ignore
 * @private
 * @param value
 * @returns {Boolean}
 */</span>
jasmine.isArray_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>
  <span class="hljs-keyword">return</span> jasmine.isA_(<span class="hljs-string">"Array"</span>, value);
};

<span class="hljs-comment">/**
 * @ignore
 * @private
 * @param value
 * @returns {Boolean}
 */</span>
jasmine.isString_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>
  <span class="hljs-keyword">return</span> jasmine.isA_(<span class="hljs-string">"String"</span>, value);
};

<span class="hljs-comment">/**
 * @ignore
 * @private
 * @param value
 * @returns {Boolean}
 */</span>
jasmine.isNumber_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>
  <span class="hljs-keyword">return</span> jasmine.isA_(<span class="hljs-string">"Number"</span>, value);
};

<span class="hljs-comment">/**
 * @ignore
 * @private
 * @param {String} typeName
 * @param value
 * @returns {Boolean}
 */</span>
jasmine.isA_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(typeName, value)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.apply(value) === <span class="hljs-string">'[object '</span> + typeName + <span class="hljs-string">']'</span>;
};

<span class="hljs-comment">/**
 * Pretty printer for expecations.  Takes any object and turns it into a human-readable string.
 *
 * @param value {Object} an object to be outputted
 * @returns {String}
 */</span>
jasmine.pp = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>
  <span class="hljs-keyword">var</span> stringPrettyPrinter = <span class="hljs-keyword">new</span> jasmine.StringPrettyPrinter();
  stringPrettyPrinter.format(value);
  <span class="hljs-keyword">return</span> stringPrettyPrinter.string;
};

<span class="hljs-comment">/**
 * Returns true if the object is a DOM Node.
 *
 * @param {Object} obj object to check
 * @returns {Boolean}
 */</span>
jasmine.isDomNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj)</span> {</span>
  <span class="hljs-keyword">return</span> obj.nodeType &gt; <span class="hljs-number">0</span>;
};

<span class="hljs-comment">/**
 * Returns a matchable 'generic' object of the class type.  For use in expecations of type when values don't matter.
 *
 * @example
 * // don't care about which function is passed in, as long as it's a function
 * expect(mySpy).toHaveBeenCalledWith(jasmine.any(Function));
 *
 * @param {Class} clazz
 * @returns matchable object of the type clazz
 */</span>
jasmine.any = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(clazz)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> jasmine.Matchers.Any(clazz);
};

<span class="hljs-comment">/**
 * Returns a matchable subset of a JSON object. For use in expectations when you don't care about all of the
 * attributes on the object.
 *
 * @example
 * // don't care about any other attributes than foo.
 * expect(mySpy).toHaveBeenCalledWith(jasmine.objectContaining({foo: "bar"});
 *
 * @param sample {Object} sample
 * @returns matchable object for the sample
 */</span>
jasmine.objectContaining = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(sample)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> jasmine.Matchers.ObjectContaining(sample);
};

<span class="hljs-comment">/**
 * Jasmine Spies are test doubles that can act as stubs, spies, fakes or when used in an expecation, mocks.
 *
 * Spies should be created in test setup, before expectations.  They can then be checked, using the standard Jasmine
 * expectation syntax. Spies can be checked if they were called or not and what the calling params were.
 *
 * A Spy has the following fields: wasCalled, callCount, mostRecentCall, and argsForCall (see docs).
 *
 * Spies are torn down at the end of every spec.
 *
 * Note: Do &lt;b&gt;not&lt;/b&gt; call new jasmine.Spy() directly - a spy must be created using spyOn, jasmine.createSpy or jasmine.createSpyObj.
 *
 * @example
 * // a stub
 * var myStub = jasmine.createSpy('myStub');  // can be used anywhere
 *
 * // spy example
 * var foo = {
 *   not: function(bool) { return !bool; }
 * }
 *
 * // actual foo.not will not be called, execution stops
 * spyOn(foo, 'not');

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>foo.not spied upon, execution will continue to implementation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre> * spyOn(foo, 'not').andCallThrough();
 *
 * // fake example
 * var foo = {
 *   not: function(bool) { return !bool; }
 * }
 *
 * // foo.not(val) will return val
 * spyOn(foo, 'not').andCallFake(function(value) {return value;});
 *
 * // mock example
 * foo.not(7 == 7);
 * expect(foo.not).toHaveBeenCalled();
 * expect(foo.not).toHaveBeenCalledWith(true);
 *
 * @constructor
 * @see spyOn, jasmine.createSpy, jasmine.createSpyObj
 * @param {String} name
 */
jasmine.Spy = function(name) {
  /**
   * The name of the spy, if provided.
   */
  this.identity = name || 'unknown';
  /**
   *  Is this Object a spy?
   */
  this.isSpy = true;
  /**
   * The actual function this spy stubs.
   */
  this.plan = function() {
  };
  /**
   * Tracking of the most recent call to the spy.
   * @example
   * var mySpy = jasmine.createSpy('foo');
   * mySpy(1, 2);
   * mySpy.mostRecentCall.args = [1, 2];
   */
  this.mostRecentCall = {};

  /**
   * Holds arguments for each call to the spy, indexed by call count
   * @example
   * var mySpy = jasmine.createSpy('foo');
   * mySpy(1, 2);
   * mySpy(7, 8);
   * mySpy.mostRecentCall.args = [7, 8];
   * mySpy.argsForCall[0] = [1, 2];
   * mySpy.argsForCall[1] = [7, 8];
   */
  this.argsForCall = [];
  this.calls = [];
};

/**
 * Tells a spy to call through to the actual implemenatation.
 *
 * @example
 * var foo = {
 *   bar: function() { // do some stuff }
 * }
 *
 * // defining a spy on an existing property: foo.bar
 * spyOn(foo, 'bar').andCallThrough();
 */
jasmine.Spy.prototype.andCallThrough = function() {
  this.plan = this.originalValue;
  return this;
};

/**
 * For setting the return value of a spy.
 *
 * @example
 * // defining a spy from scratch: foo() returns 'baz'
 * var foo = jasmine.createSpy('spy on foo').andReturn('baz');
 *
 * // defining a spy on an existing property: foo.bar() returns 'baz'
 * spyOn(foo, 'bar').andReturn('baz');
 *
 * @param {Object} value
 */
jasmine.Spy.prototype.andReturn = function(value) {
  this.plan = function() {
    return value;
  };
  return this;
};

/**
 * For throwing an exception when a spy is called.
 *
 * @example
 * // defining a spy from scratch: foo() throws an exception w/ message 'ouch'
 * var foo = jasmine.createSpy('spy on foo').andThrow('baz');
 *
 * // defining a spy on an existing property: foo.bar() throws an exception w/ message 'ouch'
 * spyOn(foo, 'bar').andThrow('baz');
 *
 * @param {String} exceptionMsg
 */
jasmine.Spy.prototype.andThrow = function(exceptionMsg) {
  this.plan = function() {
    throw exceptionMsg;
  };
  return this;
};

/**
 * Calls an alternate implementation when a spy is called.
 *
 * @example
 * var baz = function() {
 *   // do some stuff, return something
 * }
 * // defining a spy from scratch: foo() calls the function baz
 * var foo = jasmine.createSpy('spy on foo').andCall(baz);
 *
 * // defining a spy on an existing property: foo.bar() calls an anonymnous function
 * spyOn(foo, 'bar').andCall(function() { return 'baz';} );
 *
 * @param {Function} fakeFunc
 */
jasmine.Spy.prototype.andCallFake = function(fakeFunc) {
  this.plan = fakeFunc;
  return this;
};

/**
 * Resets all of a spy's the tracking variables so that it can be used again.
 *
 * @example
 * spyOn(foo, 'bar');
 *
 * foo.bar();
 *
 * expect(foo.bar.callCount).toEqual(1);
 *
 * foo.bar.reset();
 *
 * expect(foo.bar.callCount).toEqual(0);
 */
jasmine.Spy.prototype.reset = function() {
  this.wasCalled = false;
  this.callCount = 0;
  this.argsForCall = [];
  this.calls = [];
  this.mostRecentCall = {};
};

jasmine.createSpy = function(name) {

  var spyObj = function() {
    spyObj.wasCalled = true;
    spyObj.callCount++;
    var args = jasmine.util.argsToArray(arguments);
    spyObj.mostRecentCall.object = this;
    spyObj.mostRecentCall.args = args;
    spyObj.argsForCall.push(args);
    spyObj.calls.push({object: this, args: args});
    return spyObj.plan.apply(this, arguments);
  };

  var spy = new jasmine.Spy(name);

  for (var prop in spy) {
    spyObj[prop] = spy[prop];
  }

  spyObj.reset();

  return spyObj;
};

/**
 * Determines whether an object is a spy.
 *
 * @param {jasmine.Spy|Object} putativeSpy
 * @returns {Boolean}
 */
jasmine.isSpy = function(putativeSpy) {
  return putativeSpy &amp;&amp; putativeSpy.isSpy;
};

/**
 * Creates a more complicated spy: an Object that has every property a function that is a spy.  Used for stubbing something
 * large in one call.
 *
 * @param {String} baseName name of spy class
 * @param {Array} methodNames array of names of methods to make spies
 */
jasmine.createSpyObj = function(baseName, methodNames) {
  if (!jasmine.isArray_(methodNames) || methodNames.length === 0) {
    throw new Error('createSpyObj requires a non-empty array of method names to create spies for');
  }
  var obj = {};
  for (var i = 0; i &lt; methodNames.length; i++) {
    obj[methodNames[i]] = jasmine.createSpy(baseName + '.' + methodNames[i]);
  }
  return obj;
};

/**
 * All parameters are pretty-printed and concatenated together, then written to the current spec's output.
 *
 * Be careful not to leave calls to &lt;code&gt;jasmine.log&lt;/code&gt; in production code.
 */
jasmine.log = function() {
  var spec = jasmine.getEnv().currentSpec;
  spec.log.apply(spec, arguments);
};

/**
 * Function that installs a spy on an existing object's method name.  Used within a Spec to create a spy.
 *
 * @example
 * // spy example
 * var foo = {
 *   not: function(bool) { return !bool; }
 * }
 * spyOn(foo, 'not'); // actual foo.not will not be called, execution stops
 *
 * @see jasmine.createSpy
 * @param obj
 * @param methodName
 * @return {jasmine.Spy} a Jasmine spy that can be chained with all spy methods
 */
var spyOn = function(obj, methodName) {
  return jasmine.getEnv().currentSpec.spyOn(obj, methodName);
};
if (isCommonJS) exports.spyOn = spyOn;

/**
 * Creates a Jasmine spec that will be added to the current suite.
 *
 * // TODO: pending tests
 *
 * @example
 * it('should be true', function() {
 *   expect(true).toEqual(true);
 * });
 *
 * @param {String} desc description of this specification
 * @param {Function} func defines the preconditions and expectations of the spec
 */
var it = function(desc, func) {
  return jasmine.getEnv().it(desc, func);
};
if (isCommonJS) exports.it = it;

/**
 * Creates a &lt;em&gt;disabled&lt;/em&gt; Jasmine spec.
 *
 * A convenience method that allows existing specs to be disabled temporarily during development.
 *
 * @param {String} desc description of this specification
 * @param {Function} func defines the preconditions and expectations of the spec
 */
var xit = function(desc, func) {
  return jasmine.getEnv().xit(desc, func);
};
if (isCommonJS) exports.xit = xit;

/**
 * Starts a chain for a Jasmine expectation.
 *
 * It is passed an Object that is the actual value and should chain to one of the many
 * jasmine.Matchers functions.
 *
 * @param {Object} actual Actual value to test against and expected value
 * @return {jasmine.Matchers}
 */
var expect = function(actual) {
  return jasmine.getEnv().currentSpec.expect(actual);
};
if (isCommonJS) exports.expect = expect;

/**
 * Defines part of a jasmine spec.  Used in cominbination with waits or waitsFor in asynchrnous specs.
 *
 * @param {Function} func Function that defines part of a jasmine spec.
 */
var runs = function(func) {
  jasmine.getEnv().currentSpec.runs(func);
};
if (isCommonJS) exports.runs = runs;

/**
 * Waits a fixed time period before moving to the next block.
 *
 * @deprecated Use waitsFor() instead
 * @param {Number} timeout milliseconds to wait
 */
var waits = function(timeout) {
  jasmine.getEnv().currentSpec.waits(timeout);
};
if (isCommonJS) exports.waits = waits;

/**
 * Waits for the latchFunction to return true before proceeding to the next block.
 *
 * @param {Function} latchFunction
 * @param {String} optional_timeoutMessage
 * @param {Number} optional_timeout
 */
var waitsFor = function(latchFunction, optional_timeoutMessage, optional_timeout) {
  jasmine.getEnv().currentSpec.waitsFor.apply(jasmine.getEnv().currentSpec, arguments);
};
if (isCommonJS) exports.waitsFor = waitsFor;

/**
 * A function that is called before each spec in a suite.
 *
 * Used for spec setup, including validating assumptions.
 *
 * @param {Function} beforeEachFunction
 */
var beforeEach = function(beforeEachFunction) {
  jasmine.getEnv().beforeEach(beforeEachFunction);
};
if (isCommonJS) exports.beforeEach = beforeEach;

/**
 * A function that is called after each spec in a suite.
 *
 * Used for restoring any state that is hijacked during spec execution.
 *
 * @param {Function} afterEachFunction
 */
var afterEach = function(afterEachFunction) {
  jasmine.getEnv().afterEach(afterEachFunction);
};
if (isCommonJS) exports.afterEach = afterEach;

/**
 * Defines a suite of specifications.
 *
 * Stores the description and all defined specs in the Jasmine environment as one suite of specs. Variables declared
 * are accessible by calls to beforeEach, it, and afterEach. Describe blocks can be nested, allowing for specialization
 * of setup in some tests.
 *
 * @example
 * // TODO: a simple suite
 *
 * // TODO: a simple suite with a nested describe block
 *
 * @param {String} description A string, usually the class under test.
 * @param {Function} specDefinitions function that defines several specs.
 */
var describe = function(description, specDefinitions) {
  return jasmine.getEnv().describe(description, specDefinitions);
};
if (isCommonJS) exports.describe = describe;

/**
 * Disables a suite of specifications.  Used to disable some suites in a file, or files, temporarily during development.
 *
 * @param {String} description A string, usually the class under test.
 * @param {Function} specDefinitions function that defines several specs.
 */
var xdescribe = function(description, specDefinitions) {
  return jasmine.getEnv().xdescribe(description, specDefinitions);
};
if (isCommonJS) exports.xdescribe = xdescribe;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Provide the XMLHttpRequest class for IE 5.x-6.x:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.XmlHttpRequest = (<span class="hljs-keyword">typeof</span> XMLHttpRequest == <span class="hljs-string">"undefined"</span>) ? <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryIt</span><span class="hljs-params">(f)</span> {</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> f();
    } <span class="hljs-keyword">catch</span>(e) {
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> xhr = tryIt(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">"Msxml2.XMLHTTP.6.0"</span>);
  }) ||
    tryIt(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">"Msxml2.XMLHTTP.3.0"</span>);
    }) ||
    tryIt(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">"Msxml2.XMLHTTP"</span>);
    }) ||
    tryIt(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">"Microsoft.XMLHTTP"</span>);
    });

  <span class="hljs-keyword">if</span> (!xhr) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"This browser does not support XMLHttpRequest."</span>);

  <span class="hljs-keyword">return</span> xhr;
} : XMLHttpRequest;
<span class="hljs-comment">/**
 * @namespace
 */</span>
jasmine.util = {};

<span class="hljs-comment">/**
 * Declare that a child class inherit it's prototype from the parent class.
 *
 * @private
 * @param {Function} childClass
 * @param {Function} parentClass
 */</span>
jasmine.util.inherit = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(childClass, parentClass)</span> {</span>
  <span class="hljs-comment">/**
   * @private
   */</span>
  <span class="hljs-keyword">var</span> subclass = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  };
  subclass.prototype = parentClass.prototype;
  childClass.prototype = <span class="hljs-keyword">new</span> subclass();
};

jasmine.util.formatException = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(e)</span> {</span>
  <span class="hljs-keyword">var</span> lineNumber;
  <span class="hljs-keyword">if</span> (e.line) {
    lineNumber = e.line;
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.lineNumber) {
    lineNumber = e.lineNumber;
  }

  <span class="hljs-keyword">var</span> file;

  <span class="hljs-keyword">if</span> (e.sourceURL) {
    file = e.sourceURL;
  }
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.fileName) {
    file = e.fileName;
  }

  <span class="hljs-keyword">var</span> message = (e.name &amp;&amp; e.message) ? (e.name + <span class="hljs-string">': '</span> + e.message) : e.toString();

  <span class="hljs-keyword">if</span> (file &amp;&amp; lineNumber) {
    message += <span class="hljs-string">' in '</span> + file + <span class="hljs-string">' (line '</span> + lineNumber + <span class="hljs-string">')'</span>;
  }

  <span class="hljs-keyword">return</span> message;
};

jasmine.util.htmlEscape = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(str)</span> {</span>
  <span class="hljs-keyword">if</span> (!str) <span class="hljs-keyword">return</span> str;
  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">'&amp;amp;'</span>)
    .replace(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">'&amp;lt;'</span>)
    .replace(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">'&amp;gt;'</span>);
};

jasmine.util.argsToArray = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(args)</span> {</span>
  <span class="hljs-keyword">var</span> arrayOfArgs = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) arrayOfArgs.push(args[i]);
  <span class="hljs-keyword">return</span> arrayOfArgs;
};

jasmine.util.extend = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(destination, source)</span> {</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> source) destination[property] = source[property];
  <span class="hljs-keyword">return</span> destination;
};

<span class="hljs-comment">/**
 * Environment for Jasmine
 *
 * @constructor
 */</span>
jasmine.Env = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.currentSpec = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.currentSuite = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">this</span>.currentRunner_ = <span class="hljs-keyword">new</span> jasmine.Runner(<span class="hljs-keyword">this</span>);

  <span class="hljs-keyword">this</span>.reporter = <span class="hljs-keyword">new</span> jasmine.MultiReporter();

  <span class="hljs-keyword">this</span>.updateInterval = jasmine.DEFAULT_UPDATE_INTERVAL;
  <span class="hljs-keyword">this</span>.defaultTimeoutInterval = jasmine.DEFAULT_TIMEOUT_INTERVAL;
  <span class="hljs-keyword">this</span>.lastUpdate = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.specFilter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };

  <span class="hljs-keyword">this</span>.nextSpecId_ = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.nextSuiteId_ = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.equalityTesters_ = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>wrap matchers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.matchersClass = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    jasmine.Matchers.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  };
  jasmine.util.inherit(<span class="hljs-keyword">this</span>.matchersClass, jasmine.Matchers);

  jasmine.Matchers.wrapInto_(jasmine.Matchers.prototype, <span class="hljs-keyword">this</span>.matchersClass);
};


jasmine.Env.prototype.setTimeout = jasmine.setTimeout;
jasmine.Env.prototype.clearTimeout = jasmine.clearTimeout;
jasmine.Env.prototype.setInterval = jasmine.setInterval;
jasmine.Env.prototype.clearInterval = jasmine.clearInterval;

<span class="hljs-comment">/**
 * @returns an object containing jasmine version build info, if set.
 */</span>
jasmine.Env.prototype.version = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">if</span> (jasmine.version_) {
    <span class="hljs-keyword">return</span> jasmine.version_;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Version not set'</span>);
  }
};

<span class="hljs-comment">/**
 * @returns string containing jasmine version build info, if set.
 */</span>
jasmine.Env.prototype.versionString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">if</span> (!jasmine.version_) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"version unknown"</span>;
  }

  <span class="hljs-keyword">var</span> version = <span class="hljs-keyword">this</span>.version();
  <span class="hljs-keyword">var</span> versionString = version.major + <span class="hljs-string">"."</span> + version.minor + <span class="hljs-string">"."</span> + version.build;
  <span class="hljs-keyword">if</span> (version.release_candidate) {
    versionString += <span class="hljs-string">".rc"</span> + version.release_candidate;
  }
  versionString += <span class="hljs-string">" revision "</span> + version.revision;
  <span class="hljs-keyword">return</span> versionString;
};

<span class="hljs-comment">/**
 * @returns a sequential integer starting at 0
 */</span>
jasmine.Env.prototype.nextSpecId = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nextSpecId_++;
};

<span class="hljs-comment">/**
 * @returns a sequential integer starting at 0
 */</span>
jasmine.Env.prototype.nextSuiteId = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nextSuiteId_++;
};

<span class="hljs-comment">/**
 * Register a reporter to receive status updates from Jasmine.
 * @param {jasmine.Reporter} reporter An object which will receive status updates.
 */</span>
jasmine.Env.prototype.addReporter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(reporter)</span> {</span>
  <span class="hljs-keyword">this</span>.reporter.addReporter(reporter);
};

jasmine.Env.prototype.execute = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.currentRunner_.execute();
};

jasmine.Env.prototype.describe = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(description, specDefinitions)</span> {</span>
  <span class="hljs-keyword">var</span> suite = <span class="hljs-keyword">new</span> jasmine.Suite(<span class="hljs-keyword">this</span>, description, specDefinitions, <span class="hljs-keyword">this</span>.currentSuite);

  <span class="hljs-keyword">var</span> parentSuite = <span class="hljs-keyword">this</span>.currentSuite;
  <span class="hljs-keyword">if</span> (parentSuite) {
    parentSuite.add(suite);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.currentRunner_.add(suite);
  }

  <span class="hljs-keyword">this</span>.currentSuite = suite;

  <span class="hljs-keyword">var</span> declarationError = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">try</span> {
    specDefinitions.call(suite);
  } <span class="hljs-keyword">catch</span>(e) {
    declarationError = e;
  }

  <span class="hljs-keyword">if</span> (declarationError) {
    <span class="hljs-keyword">this</span>.it(<span class="hljs-string">"encountered a declaration exception"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">throw</span> declarationError;
    });
  }

  <span class="hljs-keyword">this</span>.currentSuite = parentSuite;

  <span class="hljs-keyword">return</span> suite;
};

jasmine.Env.prototype.beforeEach = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(beforeEachFunction)</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentSuite) {
    <span class="hljs-keyword">this</span>.currentSuite.beforeEach(beforeEachFunction);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.currentRunner_.beforeEach(beforeEachFunction);
  }
};

jasmine.Env.prototype.currentRunner = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.currentRunner_;
};

jasmine.Env.prototype.afterEach = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(afterEachFunction)</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentSuite) {
    <span class="hljs-keyword">this</span>.currentSuite.afterEach(afterEachFunction);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.currentRunner_.afterEach(afterEachFunction);
  }

};

jasmine.Env.prototype.xdescribe = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(desc, specDefinitions)</span> {</span>
  <span class="hljs-keyword">return</span> {
    execute: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    }
  };
};

jasmine.Env.prototype.it = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(description, func)</span> {</span>
  <span class="hljs-keyword">var</span> spec = <span class="hljs-keyword">new</span> jasmine.Spec(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.currentSuite, description);
  <span class="hljs-keyword">this</span>.currentSuite.add(spec);
  <span class="hljs-keyword">this</span>.currentSpec = spec;

  <span class="hljs-keyword">if</span> (func) {
    spec.runs(func);
  }

  <span class="hljs-keyword">return</span> spec;
};

jasmine.Env.prototype.xit = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(desc, func)</span> {</span>
  <span class="hljs-keyword">return</span> {
    id: <span class="hljs-keyword">this</span>.nextSpecId(),
    runs: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    }
  };
};

jasmine.Env.prototype.compareRegExps_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b, mismatchKeys, mismatchValues)</span> {</span>
  <span class="hljs-keyword">if</span> (a.source != b.source)
    mismatchValues.push(<span class="hljs-string">"expected pattern /"</span> + b.source + <span class="hljs-string">"/ is not equal to the pattern /"</span> + a.source + <span class="hljs-string">"/"</span>);

  <span class="hljs-keyword">if</span> (a.ignoreCase != b.ignoreCase)
    mismatchValues.push(<span class="hljs-string">"expected modifier i was"</span> + (b.ignoreCase ? <span class="hljs-string">" "</span> : <span class="hljs-string">" not "</span>) + <span class="hljs-string">"set and does not equal the origin modifier"</span>);

  <span class="hljs-keyword">if</span> (a.global != b.global)
    mismatchValues.push(<span class="hljs-string">"expected modifier g was"</span> + (b.global ? <span class="hljs-string">" "</span> : <span class="hljs-string">" not "</span>) + <span class="hljs-string">"set and does not equal the origin modifier"</span>);

  <span class="hljs-keyword">if</span> (a.multiline != b.multiline)
    mismatchValues.push(<span class="hljs-string">"expected modifier m was"</span> + (b.multiline ? <span class="hljs-string">" "</span> : <span class="hljs-string">" not "</span>) + <span class="hljs-string">"set and does not equal the origin modifier"</span>);

  <span class="hljs-keyword">if</span> (a.sticky != b.sticky)
    mismatchValues.push(<span class="hljs-string">"expected modifier y was"</span> + (b.sticky ? <span class="hljs-string">" "</span> : <span class="hljs-string">" not "</span>) + <span class="hljs-string">"set and does not equal the origin modifier"</span>);

  <span class="hljs-keyword">return</span> (mismatchValues.length === <span class="hljs-number">0</span>);
};

jasmine.Env.prototype.compareObjects_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b, mismatchKeys, mismatchValues)</span> {</span>
  <span class="hljs-keyword">if</span> (a.__Jasmine_been_here_before__ === b &amp;&amp; b.__Jasmine_been_here_before__ === a) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  a.__Jasmine_been_here_before__ = b;
  b.__Jasmine_been_here_before__ = a;

  <span class="hljs-keyword">var</span> hasKey = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj, keyName)</span> {</span>
    <span class="hljs-keyword">return</span> obj !== <span class="hljs-literal">null</span> &amp;&amp; obj[keyName] !== jasmine.undefined;
  };

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> b) {
    <span class="hljs-keyword">if</span> (!hasKey(a, property) &amp;&amp; hasKey(b, property)) {
      mismatchKeys.push(<span class="hljs-string">"expected has key '"</span> + property + <span class="hljs-string">"', but missing from actual."</span>);
    }
  }
  <span class="hljs-keyword">for</span> (property <span class="hljs-keyword">in</span> a) {
    <span class="hljs-keyword">if</span> (!hasKey(b, property) &amp;&amp; hasKey(a, property)) {
      mismatchKeys.push(<span class="hljs-string">"expected missing key '"</span> + property + <span class="hljs-string">"', but present in actual."</span>);
    }
  }
  <span class="hljs-keyword">for</span> (property <span class="hljs-keyword">in</span> b) {
    <span class="hljs-keyword">if</span> (property == <span class="hljs-string">'__Jasmine_been_here_before__'</span>) <span class="hljs-keyword">continue</span>;
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.equals_(a[property], b[property], mismatchKeys, mismatchValues)) {
      mismatchValues.push(<span class="hljs-string">"'"</span> + property + <span class="hljs-string">"' was '"</span> + (b[property] ? jasmine.util.htmlEscape(b[property].toString()) : b[property]) + <span class="hljs-string">"' in expected, but was '"</span> + (a[property] ? jasmine.util.htmlEscape(a[property].toString()) : a[property]) + <span class="hljs-string">"' in actual."</span>);
    }
  }

  <span class="hljs-keyword">if</span> (jasmine.isArray_(a) &amp;&amp; jasmine.isArray_(b) &amp;&amp; a.length != b.length) {
    mismatchValues.push(<span class="hljs-string">"arrays were not the same length"</span>);
  }

  <span class="hljs-keyword">delete</span> a.__Jasmine_been_here_before__;
  <span class="hljs-keyword">delete</span> b.__Jasmine_been_here_before__;
  <span class="hljs-keyword">return</span> (mismatchKeys.length === <span class="hljs-number">0</span> &amp;&amp; mismatchValues.length === <span class="hljs-number">0</span>);
};

jasmine.Env.prototype.equals_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b, mismatchKeys, mismatchValues)</span> {</span>
  mismatchKeys = mismatchKeys || [];
  mismatchValues = mismatchValues || [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.equalityTesters_.length; i++) {
    <span class="hljs-keyword">var</span> equalityTester = <span class="hljs-keyword">this</span>.equalityTesters_[i];
    <span class="hljs-keyword">var</span> result = equalityTester(a, b, <span class="hljs-keyword">this</span>, mismatchKeys, mismatchValues);
    <span class="hljs-keyword">if</span> (result !== jasmine.undefined) <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">if</span> (a === b) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">if</span> (a === jasmine.undefined || a === <span class="hljs-literal">null</span> || b === jasmine.undefined || b === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> (a == jasmine.undefined &amp;&amp; b == jasmine.undefined);
  }

  <span class="hljs-keyword">if</span> (jasmine.isDomNode(a) &amp;&amp; jasmine.isDomNode(b)) {
    <span class="hljs-keyword">return</span> a === b;
  }

  <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span> &amp;&amp; b <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) {
    <span class="hljs-keyword">return</span> a.getTime() == b.getTime();
  }

  <span class="hljs-keyword">if</span> (a.jasmineMatches) {
    <span class="hljs-keyword">return</span> a.jasmineMatches(b);
  }

  <span class="hljs-keyword">if</span> (b.jasmineMatches) {
    <span class="hljs-keyword">return</span> b.jasmineMatches(a);
  }

  <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> jasmine.Matchers.ObjectContaining) {
    <span class="hljs-keyword">return</span> a.matches(b);
  }

  <span class="hljs-keyword">if</span> (b <span class="hljs-keyword">instanceof</span> jasmine.Matchers.ObjectContaining) {
    <span class="hljs-keyword">return</span> b.matches(a);
  }

  <span class="hljs-keyword">if</span> (jasmine.isString_(a) &amp;&amp; jasmine.isString_(b)) {
    <span class="hljs-keyword">return</span> (a == b);
  }

  <span class="hljs-keyword">if</span> (jasmine.isNumber_(a) &amp;&amp; jasmine.isNumber_(b)) {
    <span class="hljs-keyword">return</span> (a == b);
  }

  <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span> &amp;&amp; b <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compareRegExps_(a, b, mismatchKeys, mismatchValues);
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> a === <span class="hljs-string">"object"</span> &amp;&amp; <span class="hljs-keyword">typeof</span> b === <span class="hljs-string">"object"</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.compareObjects_(a, b, mismatchKeys, mismatchValues);
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Straight check</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">return</span> (a === b);
};

jasmine.Env.prototype.contains_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(haystack, needle)</span> {</span>
  <span class="hljs-keyword">if</span> (jasmine.isArray_(haystack)) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; haystack.length; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.equals_(haystack[i], needle)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">return</span> haystack.indexOf(needle) &gt;= <span class="hljs-number">0</span>;
};

jasmine.Env.prototype.addEqualityTester = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(equalityTester)</span> {</span>
  <span class="hljs-keyword">this</span>.equalityTesters_.push(equalityTester);
};
<span class="hljs-comment">/** No-op base class for Jasmine reporters.
 *
 * @constructor
 */</span>
jasmine.Reporter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
};</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>noinspection JSUnusedLocalSymbols</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.Reporter.prototype.reportRunnerStarting = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(runner)</span> {</span>
};</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>noinspection JSUnusedLocalSymbols</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.Reporter.prototype.reportRunnerResults = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(runner)</span> {</span>
};</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>noinspection JSUnusedLocalSymbols</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.Reporter.prototype.reportSuiteResults = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(suite)</span> {</span>
};</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>noinspection JSUnusedLocalSymbols</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.Reporter.prototype.reportSpecStarting = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(spec)</span> {</span>
};</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>noinspection JSUnusedLocalSymbols</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.Reporter.prototype.reportSpecResults = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(spec)</span> {</span>
};</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>noinspection JSUnusedLocalSymbols</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.Reporter.prototype.log = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(str)</span> {</span>
};

<span class="hljs-comment">/**
 * Blocks are functions with executable code that make up a spec.
 *
 * @constructor
 * @param {jasmine.Env} env
 * @param {Function} func
 * @param {jasmine.Spec} spec
 */</span>
jasmine.Block = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(env, func, spec)</span> {</span>
  <span class="hljs-keyword">this</span>.env = env;
  <span class="hljs-keyword">this</span>.func = func;
  <span class="hljs-keyword">this</span>.spec = spec;
};

jasmine.Block.prototype.execute = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onComplete)</span> {</span>
  <span class="hljs-keyword">if</span> (!jasmine.CATCH_EXCEPTIONS) {
    <span class="hljs-keyword">this</span>.func.apply(<span class="hljs-keyword">this</span>.spec);
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">this</span>.func.apply(<span class="hljs-keyword">this</span>.spec);
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">this</span>.spec.fail(e);
    }
  }
  onComplete();
};
<span class="hljs-comment">/** JavaScript API reporter.
 *
 * @constructor
 */</span>
jasmine.JsApiReporter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.started = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.finished = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.suites_ = [];
  <span class="hljs-keyword">this</span>.results_ = {};
};

jasmine.JsApiReporter.prototype.reportRunnerStarting = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(runner)</span> {</span>
  <span class="hljs-keyword">this</span>.started = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">var</span> suites = runner.topLevelSuites();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; suites.length; i++) {
    <span class="hljs-keyword">var</span> suite = suites[i];
    <span class="hljs-keyword">this</span>.suites_.push(<span class="hljs-keyword">this</span>.summarize_(suite));
  }
};

jasmine.JsApiReporter.prototype.suites = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.suites_;
};

jasmine.JsApiReporter.prototype.summarize_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(suiteOrSpec)</span> {</span>
  <span class="hljs-keyword">var</span> isSuite = suiteOrSpec <span class="hljs-keyword">instanceof</span> jasmine.Suite;
  <span class="hljs-keyword">var</span> summary = {
    id: suiteOrSpec.id,
    name: suiteOrSpec.description,
    type: isSuite ? <span class="hljs-string">'suite'</span> : <span class="hljs-string">'spec'</span>,
    children: []
  };
  
  <span class="hljs-keyword">if</span> (isSuite) {
    <span class="hljs-keyword">var</span> children = suiteOrSpec.children();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; children.length; i++) {
      summary.children.push(<span class="hljs-keyword">this</span>.summarize_(children[i]));
    }
  }
  <span class="hljs-keyword">return</span> summary;
};

jasmine.JsApiReporter.prototype.results = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.results_;
};

jasmine.JsApiReporter.prototype.resultsForSpec = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(specId)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.results_[specId];
};</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>noinspection JSUnusedLocalSymbols</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.JsApiReporter.prototype.reportRunnerResults = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(runner)</span> {</span>
  <span class="hljs-keyword">this</span>.finished = <span class="hljs-literal">true</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>noinspection JSUnusedLocalSymbols</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.JsApiReporter.prototype.reportSuiteResults = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(suite)</span> {</span>
};</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>noinspection JSUnusedLocalSymbols</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.JsApiReporter.prototype.reportSpecResults = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(spec)</span> {</span>
  <span class="hljs-keyword">this</span>.results_[spec.id] = {
    messages: spec.results().getItems(),
    result: spec.results().failedCount &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">"failed"</span> : <span class="hljs-string">"passed"</span>
  };
};</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>noinspection JSUnusedLocalSymbols</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.JsApiReporter.prototype.log = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(str)</span> {</span>
};

jasmine.JsApiReporter.prototype.resultsForSpecs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(specIds)</span>{</span>
  <span class="hljs-keyword">var</span> results = {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; specIds.length; i++) {
    <span class="hljs-keyword">var</span> specId = specIds[i];
    results[specId] = <span class="hljs-keyword">this</span>.summarizeResult_(<span class="hljs-keyword">this</span>.results_[specId]);
  }
  <span class="hljs-keyword">return</span> results;
};

jasmine.JsApiReporter.prototype.summarizeResult_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span>{</span>
  <span class="hljs-keyword">var</span> summaryMessages = [];
  <span class="hljs-keyword">var</span> messagesLength = result.messages.length;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> messageIndex = <span class="hljs-number">0</span>; messageIndex &lt; messagesLength; messageIndex++) {
    <span class="hljs-keyword">var</span> resultMessage = result.messages[messageIndex];
    summaryMessages.push({
      text: resultMessage.type == <span class="hljs-string">'log'</span> ? resultMessage.toString() : jasmine.undefined,
      passed: resultMessage.passed ? resultMessage.passed() : <span class="hljs-literal">true</span>,
      type: resultMessage.type,
      message: resultMessage.message,
      trace: {
        stack: resultMessage.passed &amp;&amp; !resultMessage.passed() ? resultMessage.trace.stack : jasmine.undefined
      }
    });
  }

  <span class="hljs-keyword">return</span> {
    result : result.result,
    messages : summaryMessages
  };
};

<span class="hljs-comment">/**
 * @constructor
 * @param {jasmine.Env} env
 * @param actual
 * @param {jasmine.Spec} spec
 */</span>
jasmine.Matchers = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(env, actual, spec, opt_isNot)</span> {</span>
  <span class="hljs-keyword">this</span>.env = env;
  <span class="hljs-keyword">this</span>.actual = actual;
  <span class="hljs-keyword">this</span>.spec = spec;
  <span class="hljs-keyword">this</span>.isNot = opt_isNot || <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.reportWasCalled_ = <span class="hljs-literal">false</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>todo: @deprecated as of Jasmine 0.11, remove soon [xw]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.Matchers.pp = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(str)</span> {</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"jasmine.Matchers.pp() is no longer supported, please use jasmine.pp() instead!"</span>);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>todo: @deprecated Deprecated as of Jasmine 0.10. Rewrite your custom matchers to return true or false. [xw]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.Matchers.prototype.report = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result, failing_message, details)</span> {</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"As of jasmine 0.11, custom matchers must be implemented differently -- please see jasmine docs"</span>);
};

jasmine.Matchers.wrapInto_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(prototype, matchersClass)</span> {</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> methodName <span class="hljs-keyword">in</span> prototype) {
    <span class="hljs-keyword">if</span> (methodName == <span class="hljs-string">'report'</span>) <span class="hljs-keyword">continue</span>;
    <span class="hljs-keyword">var</span> orig = prototype[methodName];
    matchersClass.prototype[methodName] = jasmine.Matchers.matcherFn_(methodName, orig);
  }
};

jasmine.Matchers.matcherFn_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(matcherName, matcherFunction)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> matcherArgs = jasmine.util.argsToArray(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">var</span> result = matcherFunction.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isNot) {
      result = !result;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reportWasCalled_) <span class="hljs-keyword">return</span> result;

    <span class="hljs-keyword">var</span> message;
    <span class="hljs-keyword">if</span> (!result) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.message) {
        message = <span class="hljs-keyword">this</span>.message.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        <span class="hljs-keyword">if</span> (jasmine.isArray_(message)) {
          message = message[<span class="hljs-keyword">this</span>.isNot ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>];
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> englishyPredicate = matcherName.replace(<span class="hljs-regexp">/[A-Z]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(s)</span> {</span> <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span> + s.toLowerCase(); });
        message = <span class="hljs-string">"Expected "</span> + jasmine.pp(<span class="hljs-keyword">this</span>.actual) + (<span class="hljs-keyword">this</span>.isNot ? <span class="hljs-string">" not "</span> : <span class="hljs-string">" "</span>) + englishyPredicate;
        <span class="hljs-keyword">if</span> (matcherArgs.length &gt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; matcherArgs.length; i++) {
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) message += <span class="hljs-string">","</span>;
            message += <span class="hljs-string">" "</span> + jasmine.pp(matcherArgs[i]);
          }
        }
        message += <span class="hljs-string">"."</span>;
      }
    }
    <span class="hljs-keyword">var</span> expectationResult = <span class="hljs-keyword">new</span> jasmine.ExpectationResult({
      matcherName: matcherName,
      passed: result,
      expected: matcherArgs.length &gt; <span class="hljs-number">1</span> ? matcherArgs : matcherArgs[<span class="hljs-number">0</span>],
      actual: <span class="hljs-keyword">this</span>.actual,
      message: message
    });
    <span class="hljs-keyword">this</span>.spec.addMatcherResult(expectationResult);
    <span class="hljs-keyword">return</span> jasmine.undefined;
  };
};




<span class="hljs-comment">/**
 * toBe: compares the actual to the expected using ===
 * @param expected
 */</span>
jasmine.Matchers.prototype.toBe = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.actual === expected;
};

<span class="hljs-comment">/**
 * toNotBe: compares the actual to the expected using !==
 * @param expected
 * @deprecated as of 1.0. Use not.toBe() instead.
 */</span>
jasmine.Matchers.prototype.toNotBe = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.actual !== expected;
};

<span class="hljs-comment">/**
 * toEqual: compares the actual to the expected using common sense equality. Handles Objects, Arrays, etc.
 *
 * @param expected
 */</span>
jasmine.Matchers.prototype.toEqual = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.env.equals_(<span class="hljs-keyword">this</span>.actual, expected);
};

<span class="hljs-comment">/**
 * toNotEqual: compares the actual to the expected using the ! of jasmine.Matchers.toEqual
 * @param expected
 * @deprecated as of 1.0. Use not.toEqual() instead.
 */</span>
jasmine.Matchers.prototype.toNotEqual = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected)</span> {</span>
  <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.env.equals_(<span class="hljs-keyword">this</span>.actual, expected);
};

<span class="hljs-comment">/**
 * Matcher that compares the actual to the expected using a regular expression.  Constructs a RegExp, so takes
 * a pattern or a String.
 *
 * @param expected
 */</span>
jasmine.Matchers.prototype.toMatch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(expected).test(<span class="hljs-keyword">this</span>.actual);
};

<span class="hljs-comment">/**
 * Matcher that compares the actual to the expected using the boolean inverse of jasmine.Matchers.toMatch
 * @param expected
 * @deprecated as of 1.0. Use not.toMatch() instead.
 */</span>
jasmine.Matchers.prototype.toNotMatch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected)</span> {</span>
  <span class="hljs-keyword">return</span> !(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(expected).test(<span class="hljs-keyword">this</span>.actual));
};

<span class="hljs-comment">/**
 * Matcher that compares the actual to jasmine.undefined.
 */</span>
jasmine.Matchers.prototype.toBeDefined = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.actual !== jasmine.undefined);
};

<span class="hljs-comment">/**
 * Matcher that compares the actual to jasmine.undefined.
 */</span>
jasmine.Matchers.prototype.toBeUndefined = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.actual === jasmine.undefined);
};

<span class="hljs-comment">/**
 * Matcher that compares the actual to null.
 */</span>
jasmine.Matchers.prototype.toBeNull = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.actual === <span class="hljs-literal">null</span>);
};

<span class="hljs-comment">/**
 * Matcher that compares the actual to NaN.
 */</span>
jasmine.Matchers.prototype.toBeNaN = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
	<span class="hljs-keyword">this</span>.message = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> [ <span class="hljs-string">"Expected "</span> + jasmine.pp(<span class="hljs-keyword">this</span>.actual) + <span class="hljs-string">" to be NaN."</span> ];
	};

	<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.actual !== <span class="hljs-keyword">this</span>.actual);
};

<span class="hljs-comment">/**
 * Matcher that boolean not-nots the actual.
 */</span>
jasmine.Matchers.prototype.toBeTruthy = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> !!<span class="hljs-keyword">this</span>.actual;
};


<span class="hljs-comment">/**
 * Matcher that boolean nots the actual.
 */</span>
jasmine.Matchers.prototype.toBeFalsy = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.actual;
};


<span class="hljs-comment">/**
 * Matcher that checks to see if the actual, a Jasmine spy, was called.
 */</span>
jasmine.Matchers.prototype.toHaveBeenCalled = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'toHaveBeenCalled does not take arguments, use toHaveBeenCalledWith'</span>);
  }

  <span class="hljs-keyword">if</span> (!jasmine.isSpy(<span class="hljs-keyword">this</span>.actual)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Expected a spy, but got '</span> + jasmine.pp(<span class="hljs-keyword">this</span>.actual) + <span class="hljs-string">'.'</span>);
  }

  <span class="hljs-keyword">this</span>.message = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> [
      <span class="hljs-string">"Expected spy "</span> + <span class="hljs-keyword">this</span>.actual.identity + <span class="hljs-string">" to have been called."</span>,
      <span class="hljs-string">"Expected spy "</span> + <span class="hljs-keyword">this</span>.actual.identity + <span class="hljs-string">" not to have been called."</span>
    ];
  };

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.actual.wasCalled;
};

<span class="hljs-comment">/** @deprecated Use expect(xxx).toHaveBeenCalled() instead */</span>
jasmine.Matchers.prototype.wasCalled = jasmine.Matchers.prototype.toHaveBeenCalled;

<span class="hljs-comment">/**
 * Matcher that checks to see if the actual, a Jasmine spy, was not called.
 *
 * @deprecated Use expect(xxx).not.toHaveBeenCalled() instead
 */</span>
jasmine.Matchers.prototype.wasNotCalled = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'wasNotCalled does not take arguments'</span>);
  }

  <span class="hljs-keyword">if</span> (!jasmine.isSpy(<span class="hljs-keyword">this</span>.actual)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Expected a spy, but got '</span> + jasmine.pp(<span class="hljs-keyword">this</span>.actual) + <span class="hljs-string">'.'</span>);
  }

  <span class="hljs-keyword">this</span>.message = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> [
      <span class="hljs-string">"Expected spy "</span> + <span class="hljs-keyword">this</span>.actual.identity + <span class="hljs-string">" to not have been called."</span>,
      <span class="hljs-string">"Expected spy "</span> + <span class="hljs-keyword">this</span>.actual.identity + <span class="hljs-string">" to have been called."</span>
    ];
  };

  <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.actual.wasCalled;
};

<span class="hljs-comment">/**
 * Matcher that checks to see if the actual, a Jasmine spy, was called with a set of parameters.
 *
 * @example
 *
 */</span>
jasmine.Matchers.prototype.toHaveBeenCalledWith = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> expectedArgs = jasmine.util.argsToArray(<span class="hljs-built_in">arguments</span>);
  <span class="hljs-keyword">if</span> (!jasmine.isSpy(<span class="hljs-keyword">this</span>.actual)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Expected a spy, but got '</span> + jasmine.pp(<span class="hljs-keyword">this</span>.actual) + <span class="hljs-string">'.'</span>);
  }
  <span class="hljs-keyword">this</span>.message = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> invertedMessage = <span class="hljs-string">"Expected spy "</span> + <span class="hljs-keyword">this</span>.actual.identity + <span class="hljs-string">" not to have been called with "</span> + jasmine.pp(expectedArgs) + <span class="hljs-string">" but it was."</span>;
    <span class="hljs-keyword">var</span> positiveMessage = <span class="hljs-string">""</span>;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.actual.callCount === <span class="hljs-number">0</span>) {
      positiveMessage = <span class="hljs-string">"Expected spy "</span> + <span class="hljs-keyword">this</span>.actual.identity + <span class="hljs-string">" to have been called with "</span> + jasmine.pp(expectedArgs) + <span class="hljs-string">" but it was never called."</span>;
    } <span class="hljs-keyword">else</span> {
      positiveMessage = <span class="hljs-string">"Expected spy "</span> + <span class="hljs-keyword">this</span>.actual.identity + <span class="hljs-string">" to have been called with "</span> + jasmine.pp(expectedArgs) + <span class="hljs-string">" but actual calls were "</span> + jasmine.pp(<span class="hljs-keyword">this</span>.actual.argsForCall).replace(<span class="hljs-regexp">/^\[ | \]$/g</span>, <span class="hljs-string">''</span>)
    }
    <span class="hljs-keyword">return</span> [positiveMessage, invertedMessage];
  };

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.env.contains_(<span class="hljs-keyword">this</span>.actual.argsForCall, expectedArgs);
};

<span class="hljs-comment">/** @deprecated Use expect(xxx).toHaveBeenCalledWith() instead */</span>
jasmine.Matchers.prototype.wasCalledWith = jasmine.Matchers.prototype.toHaveBeenCalledWith;

<span class="hljs-comment">/** @deprecated Use expect(xxx).not.toHaveBeenCalledWith() instead */</span>
jasmine.Matchers.prototype.wasNotCalledWith = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> expectedArgs = jasmine.util.argsToArray(<span class="hljs-built_in">arguments</span>);
  <span class="hljs-keyword">if</span> (!jasmine.isSpy(<span class="hljs-keyword">this</span>.actual)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Expected a spy, but got '</span> + jasmine.pp(<span class="hljs-keyword">this</span>.actual) + <span class="hljs-string">'.'</span>);
  }

  <span class="hljs-keyword">this</span>.message = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> [
      <span class="hljs-string">"Expected spy not to have been called with "</span> + jasmine.pp(expectedArgs) + <span class="hljs-string">" but it was"</span>,
      <span class="hljs-string">"Expected spy to have been called with "</span> + jasmine.pp(expectedArgs) + <span class="hljs-string">" but it was"</span>
    ];
  };

  <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.env.contains_(<span class="hljs-keyword">this</span>.actual.argsForCall, expectedArgs);
};

<span class="hljs-comment">/**
 * Matcher that checks that the expected item is an element in the actual Array.
 *
 * @param {Object} expected
 */</span>
jasmine.Matchers.prototype.toContain = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.env.contains_(<span class="hljs-keyword">this</span>.actual, expected);
};

<span class="hljs-comment">/**
 * Matcher that checks that the expected item is NOT an element in the actual Array.
 *
 * @param {Object} expected
 * @deprecated as of 1.0. Use not.toContain() instead.
 */</span>
jasmine.Matchers.prototype.toNotContain = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected)</span> {</span>
  <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.env.contains_(<span class="hljs-keyword">this</span>.actual, expected);
};

jasmine.Matchers.prototype.toBeLessThan = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.actual &lt; expected;
};

jasmine.Matchers.prototype.toBeGreaterThan = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected)</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.actual &gt; expected;
};

<span class="hljs-comment">/**
 * Matcher that checks that the expected item is equal to the actual item
 * up to a given level of decimal precision (default 2).
 *
 * @param {Number} expected
 * @param {Number} precision, as number of decimal places
 */</span>
jasmine.Matchers.prototype.toBeCloseTo = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected, precision)</span> {</span>
  <span class="hljs-keyword">if</span> (!(precision === <span class="hljs-number">0</span>)) {
    precision = precision || <span class="hljs-number">2</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(expected - <span class="hljs-keyword">this</span>.actual) &lt; (<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, -precision) / <span class="hljs-number">2</span>);
};

<span class="hljs-comment">/**
 * Matcher that checks that the expected exception was thrown by the actual.
 *
 * @param {String} [expected]
 */</span>
jasmine.Matchers.prototype.toThrow = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expected)</span> {</span>
  <span class="hljs-keyword">var</span> result = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> exception;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span>.actual != <span class="hljs-string">'function'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Actual is not a function'</span>);
  }
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">this</span>.actual();
  } <span class="hljs-keyword">catch</span> (e) {
    exception = e;
  }
  <span class="hljs-keyword">if</span> (exception) {
    result = (expected === jasmine.undefined || <span class="hljs-keyword">this</span>.env.equals_(exception.message || exception, expected.message || expected));
  }

  <span class="hljs-keyword">var</span> not = <span class="hljs-keyword">this</span>.isNot ? <span class="hljs-string">"not "</span> : <span class="hljs-string">""</span>;

  <span class="hljs-keyword">this</span>.message = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (exception &amp;&amp; (expected === jasmine.undefined || !<span class="hljs-keyword">this</span>.env.equals_(exception.message || exception, expected.message || expected))) {
      <span class="hljs-keyword">return</span> [<span class="hljs-string">"Expected function "</span> + not + <span class="hljs-string">"to throw"</span>, expected ? expected.message || expected : <span class="hljs-string">"an exception"</span>, <span class="hljs-string">", but it threw"</span>, exception.message || exception].join(<span class="hljs-string">' '</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">"Expected function to throw an exception."</span>;
    }
  };

  <span class="hljs-keyword">return</span> result;
};

jasmine.Matchers.Any = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(expectedClass)</span> {</span>
  <span class="hljs-keyword">this</span>.expectedClass = expectedClass;
};

jasmine.Matchers.Any.prototype.jasmineMatches = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(other)</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.expectedClass == <span class="hljs-built_in">String</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> other == <span class="hljs-string">'string'</span> || other <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.expectedClass == <span class="hljs-built_in">Number</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> other == <span class="hljs-string">'number'</span> || other <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.expectedClass == <span class="hljs-built_in">Function</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> other == <span class="hljs-string">'function'</span> || other <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>;
  }

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.expectedClass == <span class="hljs-built_in">Object</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> other == <span class="hljs-string">'object'</span>;
  }

  <span class="hljs-keyword">return</span> other <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">this</span>.expectedClass;
};

jasmine.Matchers.Any.prototype.jasmineToString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;jasmine.any('</span> + <span class="hljs-keyword">this</span>.expectedClass + <span class="hljs-string">')&gt;'</span>;
};

jasmine.Matchers.ObjectContaining = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(sample)</span> {</span>
  <span class="hljs-keyword">this</span>.sample = sample;
};

jasmine.Matchers.ObjectContaining.prototype.jasmineMatches = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(other, mismatchKeys, mismatchValues)</span> {</span>
  mismatchKeys = mismatchKeys || [];
  mismatchValues = mismatchValues || [];

  <span class="hljs-keyword">var</span> env = jasmine.getEnv();

  <span class="hljs-keyword">var</span> hasKey = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj, keyName)</span> {</span>
    <span class="hljs-keyword">return</span> obj != <span class="hljs-literal">null</span> &amp;&amp; obj[keyName] !== jasmine.undefined;
  };

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.sample) {
    <span class="hljs-keyword">if</span> (!hasKey(other, property) &amp;&amp; hasKey(<span class="hljs-keyword">this</span>.sample, property)) {
      mismatchKeys.push(<span class="hljs-string">"expected has key '"</span> + property + <span class="hljs-string">"', but missing from actual."</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!env.equals_(<span class="hljs-keyword">this</span>.sample[property], other[property], mismatchKeys, mismatchValues)) {
      mismatchValues.push(<span class="hljs-string">"'"</span> + property + <span class="hljs-string">"' was '"</span> + (other[property] ? jasmine.util.htmlEscape(other[property].toString()) : other[property]) + <span class="hljs-string">"' in expected, but was '"</span> + (<span class="hljs-keyword">this</span>.sample[property] ? jasmine.util.htmlEscape(<span class="hljs-keyword">this</span>.sample[property].toString()) : <span class="hljs-keyword">this</span>.sample[property]) + <span class="hljs-string">"' in actual."</span>);
    }
  }

  <span class="hljs-keyword">return</span> (mismatchKeys.length === <span class="hljs-number">0</span> &amp;&amp; mismatchValues.length === <span class="hljs-number">0</span>);
};

jasmine.Matchers.ObjectContaining.prototype.jasmineToString = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">"&lt;jasmine.objectContaining("</span> + jasmine.pp(<span class="hljs-keyword">this</span>.sample) + <span class="hljs-string">")&gt;"</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Mock setTimeout, clearTimeout
Contributed by Pivotal Computer Systems, www.pivotalsf.com</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
jasmine.FakeTimer = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.reset();

  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  self.setTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(funcToCall, millis)</span> {</span>
    self.timeoutsMade++;
    self.scheduleFunction(self.timeoutsMade, funcToCall, millis, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">return</span> self.timeoutsMade;
  };

  self.setInterval = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(funcToCall, millis)</span> {</span>
    self.timeoutsMade++;
    self.scheduleFunction(self.timeoutsMade, funcToCall, millis, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">return</span> self.timeoutsMade;
  };

  self.clearTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(timeoutKey)</span> {</span>
    self.scheduledFunctions[timeoutKey] = jasmine.undefined;
  };

  self.clearInterval = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(timeoutKey)</span> {</span>
    self.scheduledFunctions[timeoutKey] = jasmine.undefined;
  };

};

jasmine.FakeTimer.prototype.reset = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.timeoutsMade = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.scheduledFunctions = {};
  <span class="hljs-keyword">this</span>.nowMillis = <span class="hljs-number">0</span>;
};

jasmine.FakeTimer.prototype.tick = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(millis)</span> {</span>
  <span class="hljs-keyword">var</span> oldMillis = <span class="hljs-keyword">this</span>.nowMillis;
  <span class="hljs-keyword">var</span> newMillis = oldMillis + millis;
  <span class="hljs-keyword">this</span>.runFunctionsWithinRange(oldMillis, newMillis);
  <span class="hljs-keyword">this</span>.nowMillis = newMillis;
};

jasmine.FakeTimer.prototype.runFunctionsWithinRange = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(oldMillis, nowMillis)</span> {</span>
  <span class="hljs-keyword">var</span> scheduledFunc;
  <span class="hljs-keyword">var</span> funcsToRun = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> timeoutKey <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.scheduledFunctions) {
    scheduledFunc = <span class="hljs-keyword">this</span>.scheduledFunctions[timeoutKey];
    <span class="hljs-keyword">if</span> (scheduledFunc != jasmine.undefined &amp;&amp;
        scheduledFunc.runAtMillis &gt;= oldMillis &amp;&amp;
        scheduledFunc.runAtMillis &lt;= nowMillis) {
      funcsToRun.push(scheduledFunc);
      <span class="hljs-keyword">this</span>.scheduledFunctions[timeoutKey] = jasmine.undefined;
    }
  }

  <span class="hljs-keyword">if</span> (funcsToRun.length &gt; <span class="hljs-number">0</span>) {
    funcsToRun.sort(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> {</span>
      <span class="hljs-keyword">return</span> a.runAtMillis - b.runAtMillis;
    });
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; funcsToRun.length; ++i) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> funcToRun = funcsToRun[i];
        <span class="hljs-keyword">this</span>.nowMillis = funcToRun.runAtMillis;
        funcToRun.funcToCall();
        <span class="hljs-keyword">if</span> (funcToRun.recurring) {
          <span class="hljs-keyword">this</span>.scheduleFunction(funcToRun.timeoutKey,
              funcToRun.funcToCall,
              funcToRun.millis,
              <span class="hljs-literal">true</span>);
        }
      } <span class="hljs-keyword">catch</span>(e) {
      }
    }
    <span class="hljs-keyword">this</span>.runFunctionsWithinRange(oldMillis, nowMillis);
  }
};

jasmine.FakeTimer.prototype.scheduleFunction = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(timeoutKey, funcToCall, millis, recurring)</span> {</span>
  <span class="hljs-keyword">this</span>.scheduledFunctions[timeoutKey] = {
    runAtMillis: <span class="hljs-keyword">this</span>.nowMillis + millis,
    funcToCall: funcToCall,
    recurring: recurring,
    timeoutKey: timeoutKey,
    millis: millis
  };
};

<span class="hljs-comment">/**
 * @namespace
 */</span>
jasmine.Clock = {
  defaultFakeTimer: <span class="hljs-keyword">new</span> jasmine.FakeTimer(),

  reset: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    jasmine.Clock.assertInstalled();
    jasmine.Clock.defaultFakeTimer.reset();
  },

  tick: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(millis)</span> {</span>
    jasmine.Clock.assertInstalled();
    jasmine.Clock.defaultFakeTimer.tick(millis);
  },

  runFunctionsWithinRange: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(oldMillis, nowMillis)</span> {</span>
    jasmine.Clock.defaultFakeTimer.runFunctionsWithinRange(oldMillis, nowMillis);
  },

  scheduleFunction: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(timeoutKey, funcToCall, millis, recurring)</span> {</span>
    jasmine.Clock.defaultFakeTimer.scheduleFunction(timeoutKey, funcToCall, millis, recurring);
  },

  useMock: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (!jasmine.Clock.isInstalled()) {
      <span class="hljs-keyword">var</span> spec = jasmine.getEnv().currentSpec;
      spec.after(jasmine.Clock.uninstallMock);

      jasmine.Clock.installMock();
    }
  },

  installMock: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    jasmine.Clock.installed = jasmine.Clock.defaultFakeTimer;
  },

  uninstallMock: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    jasmine.Clock.assertInstalled();
    jasmine.Clock.installed = jasmine.Clock.real;
  },

  real: {
    setTimeout: jasmine.getGlobal().setTimeout,
    clearTimeout: jasmine.getGlobal().clearTimeout,
    setInterval: jasmine.getGlobal().setInterval,
    clearInterval: jasmine.getGlobal().clearInterval
  },

  assertInstalled: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (!jasmine.Clock.isInstalled()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Mock clock is not installed, use jasmine.Clock.useMock()"</span>);
    }
  },

  isInstalled: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> jasmine.Clock.installed == jasmine.Clock.defaultFakeTimer;
  },

  installed: <span class="hljs-literal">null</span>
};
jasmine.Clock.installed = jasmine.Clock.real;</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>else for IE support</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>jasmine.getGlobal().setTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(funcToCall, millis)</span> {</span>
  <span class="hljs-keyword">if</span> (jasmine.Clock.installed.setTimeout.apply) {
    <span class="hljs-keyword">return</span> jasmine.Clock.installed.setTimeout.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> jasmine.Clock.installed.setTimeout(funcToCall, millis);
  }
};

jasmine.getGlobal().setInterval = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(funcToCall, millis)</span> {</span>
  <span class="hljs-keyword">if</span> (jasmine.Clock.installed.setInterval.apply) {
    <span class="hljs-keyword">return</span> jasmine.Clock.installed.setInterval.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> jasmine.Clock.installed.setInterval(funcToCall, millis);
  }
};

jasmine.getGlobal().clearTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(timeoutKey)</span> {</span>
  <span class="hljs-keyword">if</span> (jasmine.Clock.installed.clearTimeout.apply) {
    <span class="hljs-keyword">return</span> jasmine.Clock.installed.clearTimeout.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> jasmine.Clock.installed.clearTimeout(timeoutKey);
  }
};

jasmine.getGlobal().clearInterval = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(timeoutKey)</span> {</span>
  <span class="hljs-keyword">if</span> (jasmine.Clock.installed.clearTimeout.apply) {
    <span class="hljs-keyword">return</span> jasmine.Clock.installed.clearInterval.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> jasmine.Clock.installed.clearInterval(timeoutKey);
  }
};

<span class="hljs-comment">/**
 * @constructor
 */</span>
jasmine.MultiReporter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.subReporters_ = [];
};
jasmine.util.inherit(jasmine.MultiReporter, jasmine.Reporter);

jasmine.MultiReporter.prototype.addReporter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(reporter)</span> {</span>
  <span class="hljs-keyword">this</span>.subReporters_.push(reporter);
};

(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> functionNames = [
    <span class="hljs-string">"reportRunnerStarting"</span>,
    <span class="hljs-string">"reportRunnerResults"</span>,
    <span class="hljs-string">"reportSuiteResults"</span>,
    <span class="hljs-string">"reportSpecStarting"</span>,
    <span class="hljs-string">"reportSpecResults"</span>,
    <span class="hljs-string">"log"</span>
  ];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; functionNames.length; i++) {
    <span class="hljs-keyword">var</span> functionName = functionNames[i];
    jasmine.MultiReporter.prototype[functionName] = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(functionName)</span> {</span>
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-keyword">this</span>.subReporters_.length; j++) {
          <span class="hljs-keyword">var</span> subReporter = <span class="hljs-keyword">this</span>.subReporters_[j];
          <span class="hljs-keyword">if</span> (subReporter[functionName]) {
            subReporter[functionName].apply(subReporter, <span class="hljs-built_in">arguments</span>);
          }
        }
      };
    })(functionName);
  }
})();
<span class="hljs-comment">/**
 * Holds results for a set of Jasmine spec. Allows for the results array to hold another jasmine.NestedResults
 *
 * @constructor
 */</span>
jasmine.NestedResults = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-comment">/**
   * The total count of results
   */</span>
  <span class="hljs-keyword">this</span>.totalCount = <span class="hljs-number">0</span>;
  <span class="hljs-comment">/**
   * Number of passed results
   */</span>
  <span class="hljs-keyword">this</span>.passedCount = <span class="hljs-number">0</span>;
  <span class="hljs-comment">/**
   * Number of failed results
   */</span>
  <span class="hljs-keyword">this</span>.failedCount = <span class="hljs-number">0</span>;
  <span class="hljs-comment">/**
   * Was this suite/spec skipped?
   */</span>
  <span class="hljs-keyword">this</span>.skipped = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">/**
   * @ignore
   */</span>
  <span class="hljs-keyword">this</span>.items_ = [];
};

<span class="hljs-comment">/**
 * Roll up the result counts.
 *
 * @param result
 */</span>
jasmine.NestedResults.prototype.rollupCounts = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span> {</span>
  <span class="hljs-keyword">this</span>.totalCount += result.totalCount;
  <span class="hljs-keyword">this</span>.passedCount += result.passedCount;
  <span class="hljs-keyword">this</span>.failedCount += result.failedCount;
};

<span class="hljs-comment">/**
 * Adds a log message.
 * @param values Array of message parts which will be concatenated later.
 */</span>
jasmine.NestedResults.prototype.log = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(values)</span> {</span>
  <span class="hljs-keyword">this</span>.items_.push(<span class="hljs-keyword">new</span> jasmine.MessageResult(values));
};

<span class="hljs-comment">/**
 * Getter for the results: message &amp; results.
 */</span>
jasmine.NestedResults.prototype.getItems = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items_;
};

<span class="hljs-comment">/**
 * Adds a result, tracking counts (total, passed, &amp; failed)
 * @param {jasmine.ExpectationResult|jasmine.NestedResults} result
 */</span>
jasmine.NestedResults.prototype.addResult = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span> {</span>
  <span class="hljs-keyword">if</span> (result.type != <span class="hljs-string">'log'</span>) {
    <span class="hljs-keyword">if</span> (result.items_) {
      <span class="hljs-keyword">this</span>.rollupCounts(result);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.totalCount++;
      <span class="hljs-keyword">if</span> (result.passed()) {
        <span class="hljs-keyword">this</span>.passedCount++;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.failedCount++;
      }
    }
  }
  <span class="hljs-keyword">this</span>.items_.push(result);
};

<span class="hljs-comment">/**
 * @returns {Boolean} True if &lt;b&gt;everything&lt;/b&gt; below passed
 */</span>
jasmine.NestedResults.prototype.passed = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.passedCount === <span class="hljs-keyword">this</span>.totalCount;
};
<span class="hljs-comment">/**
 * Base class for pretty printing for expectation results.
 */</span>
jasmine.PrettyPrinter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.ppNestLevel_ = <span class="hljs-number">0</span>;
};

<span class="hljs-comment">/**
 * Formats a value in a nice, human-readable string.
 *
 * @param value
 */</span>
jasmine.PrettyPrinter.prototype.format = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>
  <span class="hljs-keyword">this</span>.ppNestLevel_++;
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> (value === jasmine.undefined) {
      <span class="hljs-keyword">this</span>.emitScalar(<span class="hljs-string">'undefined'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">this</span>.emitScalar(<span class="hljs-string">'null'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value === jasmine.getGlobal()) {
      <span class="hljs-keyword">this</span>.emitScalar(<span class="hljs-string">'&lt;global&gt;'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.jasmineToString) {
      <span class="hljs-keyword">this</span>.emitScalar(value.jasmineToString());
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'string'</span>) {
      <span class="hljs-keyword">this</span>.emitString(value);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (jasmine.isSpy(value)) {
      <span class="hljs-keyword">this</span>.emitScalar(<span class="hljs-string">"spy on "</span> + value.identity);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) {
      <span class="hljs-keyword">this</span>.emitScalar(value.toString());
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'function'</span>) {
      <span class="hljs-keyword">this</span>.emitScalar(<span class="hljs-string">'Function'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value.nodeType === <span class="hljs-string">'number'</span>) {
      <span class="hljs-keyword">this</span>.emitScalar(<span class="hljs-string">'HTMLNode'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) {
      <span class="hljs-keyword">this</span>.emitScalar(<span class="hljs-string">'Date('</span> + value + <span class="hljs-string">')'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.__Jasmine_been_here_before__) {
      <span class="hljs-keyword">this</span>.emitScalar(<span class="hljs-string">'&lt;circular reference: '</span> + (jasmine.isArray_(value) ? <span class="hljs-string">'Array'</span> : <span class="hljs-string">'Object'</span>) + <span class="hljs-string">'&gt;'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (jasmine.isArray_(value) || <span class="hljs-keyword">typeof</span> value == <span class="hljs-string">'object'</span>) {
      value.__Jasmine_been_here_before__ = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">if</span> (jasmine.isArray_(value)) {
        <span class="hljs-keyword">this</span>.emitArray(value);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.emitObject(value);
      }
      <span class="hljs-keyword">delete</span> value.__Jasmine_been_here_before__;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.emitScalar(value.toString());
    }
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-keyword">this</span>.ppNestLevel_--;
  }
};

jasmine.PrettyPrinter.prototype.iterateObject = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj, fn)</span> {</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> obj) {
    <span class="hljs-keyword">if</span> (!obj.hasOwnProperty(property)) <span class="hljs-keyword">continue</span>;
    <span class="hljs-keyword">if</span> (property == <span class="hljs-string">'__Jasmine_been_here_before__'</span>) <span class="hljs-keyword">continue</span>;
    fn(property, obj.__lookupGetter__ ? (obj.__lookupGetter__(property) !== jasmine.undefined &amp;&amp; 
                                         obj.__lookupGetter__(property) !== <span class="hljs-literal">null</span>) : <span class="hljs-literal">false</span>);
  }
};

jasmine.PrettyPrinter.prototype.emitArray = jasmine.unimplementedMethod_;
jasmine.PrettyPrinter.prototype.emitObject = jasmine.unimplementedMethod_;
jasmine.PrettyPrinter.prototype.emitScalar = jasmine.unimplementedMethod_;
jasmine.PrettyPrinter.prototype.emitString = jasmine.unimplementedMethod_;

jasmine.StringPrettyPrinter = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  jasmine.PrettyPrinter.call(<span class="hljs-keyword">this</span>);

  <span class="hljs-keyword">this</span>.string = <span class="hljs-string">''</span>;
};
jasmine.util.inherit(jasmine.StringPrettyPrinter, jasmine.PrettyPrinter);

jasmine.StringPrettyPrinter.prototype.emitScalar = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>
  <span class="hljs-keyword">this</span>.append(value);
};

jasmine.StringPrettyPrinter.prototype.emitString = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>
  <span class="hljs-keyword">this</span>.append(<span class="hljs-string">"'"</span> + value + <span class="hljs-string">"'"</span>);
};

jasmine.StringPrettyPrinter.prototype.emitArray = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(array)</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ppNestLevel_ &gt; jasmine.MAX_PRETTY_PRINT_DEPTH) {
    <span class="hljs-keyword">this</span>.append(<span class="hljs-string">"Array"</span>);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">this</span>.append(<span class="hljs-string">'[ '</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) {
    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.append(<span class="hljs-string">', '</span>);
    }
    <span class="hljs-keyword">this</span>.format(array[i]);
  }
  <span class="hljs-keyword">this</span>.append(<span class="hljs-string">' ]'</span>);
};

jasmine.StringPrettyPrinter.prototype.emitObject = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj)</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ppNestLevel_ &gt; jasmine.MAX_PRETTY_PRINT_DEPTH) {
    <span class="hljs-keyword">this</span>.append(<span class="hljs-string">"Object"</span>);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">this</span>.append(<span class="hljs-string">'{ '</span>);
  <span class="hljs-keyword">var</span> first = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">this</span>.iterateObject(obj, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(property, isGetter)</span> {</span>
    <span class="hljs-keyword">if</span> (first) {
      first = <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> {
      self.append(<span class="hljs-string">', '</span>);
    }

    self.append(property);
    self.append(<span class="hljs-string">' : '</span>);
    <span class="hljs-keyword">if</span> (isGetter) {
      self.append(<span class="hljs-string">'&lt;getter&gt;'</span>);
    } <span class="hljs-keyword">else</span> {
      self.format(obj[property]);
    }
  });

  <span class="hljs-keyword">this</span>.append(<span class="hljs-string">' }'</span>);
};

jasmine.StringPrettyPrinter.prototype.append = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>
  <span class="hljs-keyword">this</span>.string += value;
};
jasmine.Queue = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(env)</span> {</span>
  <span class="hljs-keyword">this</span>.env = env;</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>parallel to blocks. each true value in this array means the block will
get executed even if we abort</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">this</span>.ensured = [];
  <span class="hljs-keyword">this</span>.blocks = [];
  <span class="hljs-keyword">this</span>.running = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">this</span>.index = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.offset = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">this</span>.abort = <span class="hljs-literal">false</span>;
};

jasmine.Queue.prototype.addBefore = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(block, ensure)</span> {</span>
  <span class="hljs-keyword">if</span> (ensure === jasmine.undefined) {
    ensure = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">this</span>.blocks.unshift(block);
  <span class="hljs-keyword">this</span>.ensured.unshift(ensure);
};

jasmine.Queue.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(block, ensure)</span> {</span>
  <span class="hljs-keyword">if</span> (ensure === jasmine.undefined) {
    ensure = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">this</span>.blocks.push(block);
  <span class="hljs-keyword">this</span>.ensured.push(ensure);
};

jasmine.Queue.prototype.insertNext = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(block, ensure)</span> {</span>
  <span class="hljs-keyword">if</span> (ensure === jasmine.undefined) {
    ensure = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">this</span>.ensured.splice((<span class="hljs-keyword">this</span>.index + <span class="hljs-keyword">this</span>.offset + <span class="hljs-number">1</span>), <span class="hljs-number">0</span>, ensure);
  <span class="hljs-keyword">this</span>.blocks.splice((<span class="hljs-keyword">this</span>.index + <span class="hljs-keyword">this</span>.offset + <span class="hljs-number">1</span>), <span class="hljs-number">0</span>, block);
  <span class="hljs-keyword">this</span>.offset++;
};

jasmine.Queue.prototype.start = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onComplete)</span> {</span>
  <span class="hljs-keyword">this</span>.running = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">this</span>.onComplete = onComplete;
  <span class="hljs-keyword">this</span>.next_();
};

jasmine.Queue.prototype.isRunning = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.running;
};

jasmine.Queue.LOOP_DONT_RECURSE = <span class="hljs-literal">true</span>;

jasmine.Queue.prototype.next_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">var</span> goAgain = <span class="hljs-literal">true</span>;

  <span class="hljs-keyword">while</span> (goAgain) {
    goAgain = <span class="hljs-literal">false</span>;
    
    <span class="hljs-keyword">if</span> (self.index &lt; self.blocks.length &amp;&amp; !(<span class="hljs-keyword">this</span>.abort &amp;&amp; !<span class="hljs-keyword">this</span>.ensured[self.index])) {
      <span class="hljs-keyword">var</span> calledSynchronously = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">var</span> completedSynchronously = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">var</span> onComplete = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">if</span> (jasmine.Queue.LOOP_DONT_RECURSE &amp;&amp; calledSynchronously) {
          completedSynchronously = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (self.blocks[self.index].abort) {
          self.abort = <span class="hljs-literal">true</span>;
        }

        self.offset = <span class="hljs-number">0</span>;
        self.index++;

        <span class="hljs-keyword">var</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();
        <span class="hljs-keyword">if</span> (self.env.updateInterval &amp;&amp; now - self.env.lastUpdate &gt; self.env.updateInterval) {
          self.env.lastUpdate = now;
          self.env.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
            self.next_();
          }, <span class="hljs-number">0</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (jasmine.Queue.LOOP_DONT_RECURSE &amp;&amp; completedSynchronously) {
            goAgain = <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> {
            self.next_();
          }
        }
      };
      self.blocks[self.index].execute(onComplete);

      calledSynchronously = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (completedSynchronously) {
        onComplete();
      }
      
    } <span class="hljs-keyword">else</span> {
      self.running = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (self.onComplete) {
        self.onComplete();
      }
    }
  }
};

jasmine.Queue.prototype.results = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> results = <span class="hljs-keyword">new</span> jasmine.NestedResults();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.blocks.length; i++) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.blocks[i].results) {
      results.addResult(<span class="hljs-keyword">this</span>.blocks[i].results());
    }
  }
  <span class="hljs-keyword">return</span> results;
};


<span class="hljs-comment">/**
 * Runner
 *
 * @constructor
 * @param {jasmine.Env} env
 */</span>
jasmine.Runner = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(env)</span> {</span>
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  self.env = env;
  self.queue = <span class="hljs-keyword">new</span> jasmine.Queue(env);
  self.before_ = [];
  self.after_ = [];
  self.suites_ = [];
};

jasmine.Runner.prototype.execute = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">if</span> (self.env.reporter.reportRunnerStarting) {
    self.env.reporter.reportRunnerStarting(<span class="hljs-keyword">this</span>);
  }
  self.queue.start(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    self.finishCallback();
  });
};

jasmine.Runner.prototype.beforeEach = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(beforeEachFunction)</span> {</span>
  beforeEachFunction.typeName = <span class="hljs-string">'beforeEach'</span>;
  <span class="hljs-keyword">this</span>.before_.splice(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,beforeEachFunction);
};

jasmine.Runner.prototype.afterEach = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(afterEachFunction)</span> {</span>
  afterEachFunction.typeName = <span class="hljs-string">'afterEach'</span>;
  <span class="hljs-keyword">this</span>.after_.splice(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,afterEachFunction);
};


jasmine.Runner.prototype.finishCallback = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.env.reporter.reportRunnerResults(<span class="hljs-keyword">this</span>);
};

jasmine.Runner.prototype.addSuite = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(suite)</span> {</span>
  <span class="hljs-keyword">this</span>.suites_.push(suite);
};

jasmine.Runner.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(block)</span> {</span>
  <span class="hljs-keyword">if</span> (block <span class="hljs-keyword">instanceof</span> jasmine.Suite) {
    <span class="hljs-keyword">this</span>.addSuite(block);
  }
  <span class="hljs-keyword">this</span>.queue.add(block);
};

jasmine.Runner.prototype.specs = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> suites = <span class="hljs-keyword">this</span>.suites();
  <span class="hljs-keyword">var</span> specs = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; suites.length; i++) {
    specs = specs.concat(suites[i].specs());
  }
  <span class="hljs-keyword">return</span> specs;
};

jasmine.Runner.prototype.suites = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.suites_;
};

jasmine.Runner.prototype.topLevelSuites = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> topLevelSuites = [];
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.suites_.length; i++) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.suites_[i].parentSuite) {
      topLevelSuites.push(<span class="hljs-keyword">this</span>.suites_[i]);
    }
  }
  <span class="hljs-keyword">return</span> topLevelSuites;
};

jasmine.Runner.prototype.results = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.queue.results();
};
<span class="hljs-comment">/**
 * Internal representation of a Jasmine specification, or test.
 *
 * @constructor
 * @param {jasmine.Env} env
 * @param {jasmine.Suite} suite
 * @param {String} description
 */</span>
jasmine.Spec = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(env, suite, description)</span> {</span>
  <span class="hljs-keyword">if</span> (!env) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'jasmine.Env() required'</span>);
  }
  <span class="hljs-keyword">if</span> (!suite) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'jasmine.Suite() required'</span>);
  }
  <span class="hljs-keyword">var</span> spec = <span class="hljs-keyword">this</span>;
  spec.id = env.nextSpecId ? env.nextSpecId() : <span class="hljs-literal">null</span>;
  spec.env = env;
  spec.suite = suite;
  spec.description = description;
  spec.queue = <span class="hljs-keyword">new</span> jasmine.Queue(env);

  spec.afterCallbacks = [];
  spec.spies_ = [];

  spec.results_ = <span class="hljs-keyword">new</span> jasmine.NestedResults();
  spec.results_.description = description;
  spec.matchersClass = <span class="hljs-literal">null</span>;
};

jasmine.Spec.prototype.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.suite.getFullName() + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.description + <span class="hljs-string">'.'</span>;
};


jasmine.Spec.prototype.results = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.results_;
};

<span class="hljs-comment">/**
 * All parameters are pretty-printed and concatenated together, then written to the spec's output.
 *
 * Be careful not to leave calls to &lt;code&gt;jasmine.log&lt;/code&gt; in production code.
 */</span>
jasmine.Spec.prototype.log = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.results_.log(<span class="hljs-built_in">arguments</span>);
};

jasmine.Spec.prototype.runs = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(func)</span> {</span>
  <span class="hljs-keyword">var</span> block = <span class="hljs-keyword">new</span> jasmine.Block(<span class="hljs-keyword">this</span>.env, func, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">this</span>.addToQueue(block);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

jasmine.Spec.prototype.addToQueue = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(block)</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.queue.isRunning()) {
    <span class="hljs-keyword">this</span>.queue.insertNext(block);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.queue.add(block);
  }
};

<span class="hljs-comment">/**
 * @param {jasmine.ExpectationResult} result
 */</span>
jasmine.Spec.prototype.addMatcherResult = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(result)</span> {</span>
  <span class="hljs-keyword">this</span>.results_.addResult(result);
};

jasmine.Spec.prototype.expect = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(actual)</span> {</span>
  <span class="hljs-keyword">var</span> positive = <span class="hljs-keyword">new</span> (<span class="hljs-keyword">this</span>.getMatchersClass_())(<span class="hljs-keyword">this</span>.env, actual, <span class="hljs-keyword">this</span>);
  positive.not = <span class="hljs-keyword">new</span> (<span class="hljs-keyword">this</span>.getMatchersClass_())(<span class="hljs-keyword">this</span>.env, actual, <span class="hljs-keyword">this</span>, <span class="hljs-literal">true</span>);
  <span class="hljs-keyword">return</span> positive;
};

<span class="hljs-comment">/**
 * Waits a fixed time period before moving to the next block.
 *
 * @deprecated Use waitsFor() instead
 * @param {Number} timeout milliseconds to wait
 */</span>
jasmine.Spec.prototype.waits = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(timeout)</span> {</span>
  <span class="hljs-keyword">var</span> waitsFunc = <span class="hljs-keyword">new</span> jasmine.WaitsBlock(<span class="hljs-keyword">this</span>.env, timeout, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">this</span>.addToQueue(waitsFunc);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

<span class="hljs-comment">/**
 * Waits for the latchFunction to return true before proceeding to the next block.
 *
 * @param {Function} latchFunction
 * @param {String} optional_timeoutMessage
 * @param {Number} optional_timeout
 */</span>
jasmine.Spec.prototype.waitsFor = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(latchFunction, optional_timeoutMessage, optional_timeout)</span> {</span>
  <span class="hljs-keyword">var</span> latchFunction_ = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> optional_timeoutMessage_ = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> optional_timeout_ = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) {
    <span class="hljs-keyword">var</span> arg = <span class="hljs-built_in">arguments</span>[i];
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> arg) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'function'</span>:
        latchFunction_ = arg;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'string'</span>:
        optional_timeoutMessage_ = arg;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">'number'</span>:
        optional_timeout_ = arg;
        <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">var</span> waitsForFunc = <span class="hljs-keyword">new</span> jasmine.WaitsForBlock(<span class="hljs-keyword">this</span>.env, optional_timeout_, latchFunction_, optional_timeoutMessage_, <span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">this</span>.addToQueue(waitsForFunc);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};

jasmine.Spec.prototype.fail = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
  <span class="hljs-keyword">var</span> expectationResult = <span class="hljs-keyword">new</span> jasmine.ExpectationResult({
    passed: <span class="hljs-literal">false</span>,
    message: e ? jasmine.util.formatException(e) : <span class="hljs-string">'Exception'</span>,
    trace: { stack: e.stack }
  });
  <span class="hljs-keyword">this</span>.results_.addResult(expectationResult);
};

jasmine.Spec.prototype.getMatchersClass_ = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.matchersClass || <span class="hljs-keyword">this</span>.env.matchersClass;
};

jasmine.Spec.prototype.addMatchers = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(matchersPrototype)</span> {</span>
  <span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">this</span>.getMatchersClass_();
  <span class="hljs-keyword">var</span> newMatchersClass = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    parent.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  };
  jasmine.util.inherit(newMatchersClass, parent);
  jasmine.Matchers.wrapInto_(matchersPrototype, newMatchersClass);
  <span class="hljs-keyword">this</span>.matchersClass = newMatchersClass;
};

jasmine.Spec.prototype.finishCallback = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">this</span>.env.reporter.reportSpecResults(<span class="hljs-keyword">this</span>);
};

jasmine.Spec.prototype.finish = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onComplete)</span> {</span>
  <span class="hljs-keyword">this</span>.removeAllSpies();
  <span class="hljs-keyword">this</span>.finishCallback();
  <span class="hljs-keyword">if</span> (onComplete) {
    onComplete();
  }
};

jasmine.Spec.prototype.after = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(doAfter)</span> {</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.queue.isRunning()) {
    <span class="hljs-keyword">this</span>.queue.add(<span class="hljs-keyword">new</span> jasmine.Block(<span class="hljs-keyword">this</span>.env, doAfter, <span class="hljs-keyword">this</span>), <span class="hljs-literal">true</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.afterCallbacks.unshift(doAfter);
  }
};

jasmine.Spec.prototype.execute = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onComplete)</span> {</span>
  <span class="hljs-keyword">var</span> spec = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">if</span> (!spec.env.specFilter(spec)) {
    spec.results_.skipped = <span class="hljs-literal">true</span>;
    spec.finish(onComplete);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">this</span>.env.reporter.reportSpecStarting(<span class="hljs-keyword">this</span>);

  spec.env.currentSpec = spec;

  spec.addBeforesAndAftersToQueue();

  spec.queue.start(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    spec.finish(onComplete);
  });
};

jasmine.Spec.prototype.addBeforesAndAftersToQueue = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> runner = <span class="hljs-keyword">this</span>.env.currentRunner();
  <span class="hljs-keyword">var</span> i;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> suite = <span class="hljs-keyword">this</span>.suite; suite; suite = suite.parentSuite) {
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; suite.before_.length; i++) {
      <span class="hljs-keyword">this</span>.queue.addBefore(<span class="hljs-keyword">new</span> jasmine.Block(<span class="hljs-keyword">this</span>.env, suite.before_[i], <span class="hljs-keyword">this</span>));
    }
  }
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; runner.before_.length; i++) {
    <span class="hljs-keyword">this</span>.queue.addBefore(<span class="hljs-keyword">new</span> jasmine.Block(<span class="hljs-keyword">this</span>.env, runner.before_[i], <span class="hljs-keyword">this</span>));
  }
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.afterCallbacks.length; i++) {
    <span class="hljs-keyword">this</span>.queue.add(<span class="hljs-keyword">new</span> jasmine.Block(<span class="hljs-keyword">this</span>.env, <span class="hljs-keyword">this</span>.afterCallbacks[i], <span class="hljs-keyword">this</span>), <span class="hljs-literal">true</span>);
  }
  <span class="hljs-keyword">for</span> (suite = <span class="hljs-keyword">this</span>.suite; suite; suite = suite.parentSuite) {
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; suite.after_.length; i++) {
      <span class="hljs-keyword">this</span>.queue.add(<span class="hljs-keyword">new</span> jasmine.Block(<span class="hljs-keyword">this</span>.env, suite.after_[i], <span class="hljs-keyword">this</span>), <span class="hljs-literal">true</span>);
    }
  }
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; runner.after_.length; i++) {
    <span class="hljs-keyword">this</span>.queue.add(<span class="hljs-keyword">new</span> jasmine.Block(<span class="hljs-keyword">this</span>.env, runner.after_[i], <span class="hljs-keyword">this</span>), <span class="hljs-literal">true</span>);
  }
};

jasmine.Spec.prototype.explodes = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">throw</span> <span class="hljs-string">'explodes function should not have been called'</span>;
};

jasmine.Spec.prototype.spyOn = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj, methodName, ignoreMethodDoesntExist)</span> {</span>
  <span class="hljs-keyword">if</span> (obj == jasmine.undefined) {
    <span class="hljs-keyword">throw</span> <span class="hljs-string">"spyOn could not find an object to spy upon for "</span> + methodName + <span class="hljs-string">"()"</span>;
  }

  <span class="hljs-keyword">if</span> (!ignoreMethodDoesntExist &amp;&amp; obj[methodName] === jasmine.undefined) {
    <span class="hljs-keyword">throw</span> methodName + <span class="hljs-string">'() method does not exist'</span>;
  }

  <span class="hljs-keyword">if</span> (!ignoreMethodDoesntExist &amp;&amp; obj[methodName] &amp;&amp; obj[methodName].isSpy) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(methodName + <span class="hljs-string">' has already been spied upon'</span>);
  }

  <span class="hljs-keyword">var</span> spyObj = jasmine.createSpy(methodName);

  <span class="hljs-keyword">this</span>.spies_.push(spyObj);
  spyObj.baseObj = obj;
  spyObj.methodName = methodName;
  spyObj.originalValue = obj[methodName];

  obj[methodName] = spyObj;

  <span class="hljs-keyword">return</span> spyObj;
};

jasmine.Spec.prototype.removeAllSpies = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.spies_.length; i++) {
    <span class="hljs-keyword">var</span> spy = <span class="hljs-keyword">this</span>.spies_[i];
    spy.baseObj[spy.methodName] = spy.originalValue;
  }
  <span class="hljs-keyword">this</span>.spies_ = [];
};

<span class="hljs-comment">/**
 * Internal representation of a Jasmine suite.
 *
 * @constructor
 * @param {jasmine.Env} env
 * @param {String} description
 * @param {Function} specDefinitions
 * @param {jasmine.Suite} parentSuite
 */</span>
jasmine.Suite = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(env, description, specDefinitions, parentSuite)</span> {</span>
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  self.id = env.nextSuiteId ? env.nextSuiteId() : <span class="hljs-literal">null</span>;
  self.description = description;
  self.queue = <span class="hljs-keyword">new</span> jasmine.Queue(env);
  self.parentSuite = parentSuite;
  self.env = env;
  self.before_ = [];
  self.after_ = [];
  self.children_ = [];
  self.suites_ = [];
  self.specs_ = [];
};

jasmine.Suite.prototype.getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">var</span> fullName = <span class="hljs-keyword">this</span>.description;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> parentSuite = <span class="hljs-keyword">this</span>.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {
    fullName = parentSuite.description + <span class="hljs-string">' '</span> + fullName;
  }
  <span class="hljs-keyword">return</span> fullName;
};

jasmine.Suite.prototype.finish = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onComplete)</span> {</span>
  <span class="hljs-keyword">this</span>.env.reporter.reportSuiteResults(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">this</span>.finished = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(onComplete) == <span class="hljs-string">'function'</span>) {
    onComplete();
  }
};

jasmine.Suite.prototype.beforeEach = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(beforeEachFunction)</span> {</span>
  beforeEachFunction.typeName = <span class="hljs-string">'beforeEach'</span>;
  <span class="hljs-keyword">this</span>.before_.unshift(beforeEachFunction);
};

jasmine.Suite.prototype.afterEach = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(afterEachFunction)</span> {</span>
  afterEachFunction.typeName = <span class="hljs-string">'afterEach'</span>;
  <span class="hljs-keyword">this</span>.after_.unshift(afterEachFunction);
};

jasmine.Suite.prototype.results = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.queue.results();
};

jasmine.Suite.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(suiteOrSpec)</span> {</span>
  <span class="hljs-keyword">this</span>.children_.push(suiteOrSpec);
  <span class="hljs-keyword">if</span> (suiteOrSpec <span class="hljs-keyword">instanceof</span> jasmine.Suite) {
    <span class="hljs-keyword">this</span>.suites_.push(suiteOrSpec);
    <span class="hljs-keyword">this</span>.env.currentRunner().addSuite(suiteOrSpec);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.specs_.push(suiteOrSpec);
  }
  <span class="hljs-keyword">this</span>.queue.add(suiteOrSpec);
};

jasmine.Suite.prototype.specs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.specs_;
};

jasmine.Suite.prototype.suites = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.suites_;
};

jasmine.Suite.prototype.children = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.children_;
};

jasmine.Suite.prototype.execute = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onComplete)</span> {</span>
  <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
  <span class="hljs-keyword">this</span>.queue.start(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    self.finish(onComplete);
  });
};
jasmine.WaitsBlock = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(env, timeout, spec)</span> {</span>
  <span class="hljs-keyword">this</span>.timeout = timeout;
  jasmine.Block.call(<span class="hljs-keyword">this</span>, env, <span class="hljs-literal">null</span>, spec);
};

jasmine.util.inherit(jasmine.WaitsBlock, jasmine.Block);

jasmine.WaitsBlock.prototype.execute = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(onComplete)</span> {</span>
  <span class="hljs-keyword">if</span> (jasmine.VERBOSE) {
    <span class="hljs-keyword">this</span>.env.reporter.log(<span class="hljs-string">'&gt;&gt; Jasmine waiting for '</span> + <span class="hljs-keyword">this</span>.timeout + <span class="hljs-string">' ms...'</span>);
  }
  <span class="hljs-keyword">this</span>.env.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    onComplete();
  }, <span class="hljs-keyword">this</span>.timeout);
};
<span class="hljs-comment">/**
 * A block which waits for some condition to become true, with timeout.
 *
 * @constructor
 * @extends jasmine.Block
 * @param {jasmine.Env} env The Jasmine environment.
 * @param {Number} timeout The maximum time in milliseconds to wait for the condition to become true.
 * @param {Function} latchFunction A function which returns true when the desired condition has been met.
 * @param {String} message The message to display if the desired condition hasn't been met within the given time period.
 * @param {jasmine.Spec} spec The Jasmine spec.
 */</span>
jasmine.WaitsForBlock = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(env, timeout, latchFunction, message, spec)</span> {</span>
  <span class="hljs-keyword">this</span>.timeout = timeout || env.defaultTimeoutInterval;
  <span class="hljs-keyword">this</span>.latchFunction = latchFunction;
  <span class="hljs-keyword">this</span>.message = message;
  <span class="hljs-keyword">this</span>.totalTimeSpentWaitingForLatch = <span class="hljs-number">0</span>;
  jasmine.Block.call(<span class="hljs-keyword">this</span>, env, <span class="hljs-literal">null</span>, spec);
};
jasmine.util.inherit(jasmine.WaitsForBlock, jasmine.Block);

jasmine.WaitsForBlock.TIMEOUT_INCREMENT = <span class="hljs-number">10</span>;

jasmine.WaitsForBlock.prototype.execute = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onComplete)</span> {</span>
  <span class="hljs-keyword">if</span> (jasmine.VERBOSE) {
    <span class="hljs-keyword">this</span>.env.reporter.log(<span class="hljs-string">'&gt;&gt; Jasmine waiting for '</span> + (<span class="hljs-keyword">this</span>.message || <span class="hljs-string">'something to happen'</span>));
  }
  <span class="hljs-keyword">var</span> latchFunctionResult;
  <span class="hljs-keyword">try</span> {
    latchFunctionResult = <span class="hljs-keyword">this</span>.latchFunction.apply(<span class="hljs-keyword">this</span>.spec);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">this</span>.spec.fail(e);
    onComplete();
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">if</span> (latchFunctionResult) {
    onComplete();
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.totalTimeSpentWaitingForLatch &gt;= <span class="hljs-keyword">this</span>.timeout) {
    <span class="hljs-keyword">var</span> message = <span class="hljs-string">'timed out after '</span> + <span class="hljs-keyword">this</span>.timeout + <span class="hljs-string">' msec waiting for '</span> + (<span class="hljs-keyword">this</span>.message || <span class="hljs-string">'something to happen'</span>);
    <span class="hljs-keyword">this</span>.spec.fail({
      name: <span class="hljs-string">'timeout'</span>,
      message: message
    });

    <span class="hljs-keyword">this</span>.abort = <span class="hljs-literal">true</span>;
    onComplete();
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">this</span>.totalTimeSpentWaitingForLatch += jasmine.WaitsForBlock.TIMEOUT_INCREMENT;
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.env.setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
      self.execute(onComplete);
    }, jasmine.WaitsForBlock.TIMEOUT_INCREMENT);
  }
};

jasmine.version_= {
  <span class="hljs-string">"major"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-string">"minor"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-string">"build"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-string">"revision"</span>: <span class="hljs-number">1354556913</span>
};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
